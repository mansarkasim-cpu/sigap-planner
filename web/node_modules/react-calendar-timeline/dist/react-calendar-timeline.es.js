import { jsx as j, jsxs as ze } from "react/jsx-runtime";
import Z, { createElement as Tt, useContext as wi, Component as ae, createRef as xi, PureComponent as Ts } from "react";
import ue from "dayjs";
function Hn(a) {
  let i = 0, s = 0, u = !0;
  for (; a; )
    !a.offsetParent && a.tagName === "BODY" && a.scrollLeft === 0 && a.scrollTop === 0 && (a = document.scrollingElement || a), i += a.offsetLeft - (u ? 0 : a.scrollLeft) + a.clientLeft, s += a.offsetTop - (u ? 0 : a.scrollTop) + a.clientTop, a = a.offsetParent, u = !1;
  return { x: i, y: s };
}
function Ot(a) {
  if (a === document.body)
    return { scrollLeft: 0, scrollTop: 0 };
  {
    const i = Ot(a.parentNode);
    return {
      scrollLeft: a.scrollLeft + i.scrollLeft,
      scrollTop: a.scrollTop + i.scrollTop
    };
  }
}
function Ct(a) {
  if (a === document.body || !a.offsetParent)
    return { offsetLeft: 0, offsetTop: 0 };
  {
    const i = Ct(a.offsetParent);
    return {
      offsetLeft: a.offsetLeft + i.offsetLeft,
      offsetTop: a.offsetTop + i.offsetTop
    };
  }
}
var Ie = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function rt(a) {
  return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a.default : a;
}
var Et = { exports: {} };
Et.exports;
(function(a, i) {
  (function(s, u) {
    a.exports = u();
  })(Ie, function() {
    function s(t, e) {
      var r = Object.keys(t);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(t);
        e && (n = n.filter(function(o) {
          return Object.getOwnPropertyDescriptor(t, o).enumerable;
        })), r.push.apply(r, n);
      }
      return r;
    }
    function u(t) {
      for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? s(Object(r), !0).forEach(function(n) {
          S(t, n, r[n]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : s(Object(r)).forEach(function(n) {
          Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n));
        });
      }
      return t;
    }
    function v(t) {
      return v = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e;
      } : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
      }, v(t);
    }
    function f(t, e) {
      if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function");
    }
    function m(t, e) {
      for (var r = 0; r < e.length; r++) {
        var n = e[r];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, O(n.key), n);
      }
    }
    function y(t, e, r) {
      return e && m(t.prototype, e), Object.defineProperty(t, "prototype", { writable: !1 }), t;
    }
    function S(t, e, r) {
      return (e = O(e)) in t ? Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : t[e] = r, t;
    }
    function C(t, e) {
      if (typeof e != "function" && e !== null) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && R(t, e);
    }
    function D(t) {
      return D = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e) {
        return e.__proto__ || Object.getPrototypeOf(e);
      }, D(t);
    }
    function R(t, e) {
      return R = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
        return r.__proto__ = n, r;
      }, R(t, e);
    }
    function T(t) {
      if (t === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t;
    }
    function P(t) {
      var e = function() {
        if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
        if (typeof Proxy == "function") return !0;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), !0;
        } catch {
          return !1;
        }
      }();
      return function() {
        var r, n = D(t);
        if (e) {
          var o = D(this).constructor;
          r = Reflect.construct(n, arguments, o);
        } else r = n.apply(this, arguments);
        return function(l, c) {
          if (c && (typeof c == "object" || typeof c == "function")) return c;
          if (c !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
          return T(l);
        }(this, r);
      };
    }
    function _() {
      return _ = typeof Reflect < "u" && Reflect.get ? Reflect.get.bind() : function(t, e, r) {
        var n = function(l, c) {
          for (; !Object.prototype.hasOwnProperty.call(l, c) && (l = D(l)) !== null; ) ;
          return l;
        }(t, e);
        if (n) {
          var o = Object.getOwnPropertyDescriptor(n, e);
          return o.get ? o.get.call(arguments.length < 3 ? t : r) : o.value;
        }
      }, _.apply(this, arguments);
    }
    function O(t) {
      var e = function(r, n) {
        if (typeof r != "object" || r === null) return r;
        var o = r[Symbol.toPrimitive];
        if (o !== void 0) {
          var l = o.call(r, n);
          if (typeof l != "object") return l;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return String(r);
      }(t, "string");
      return typeof e == "symbol" ? e : e + "";
    }
    var k = function(t) {
      return !(!t || !t.Window) && t instanceof t.Window;
    }, L = void 0, H = void 0;
    function X(t) {
      L = t;
      var e = t.document.createTextNode("");
      e.ownerDocument !== t.document && typeof t.wrap == "function" && t.wrap(e) === e && (t = t.wrap(t)), H = t;
    }
    function B(t) {
      return k(t) ? t : (t.ownerDocument || t).defaultView || H.window;
    }
    typeof window < "u" && window && X(window);
    var V = function(t) {
      return !!t && v(t) === "object";
    }, le = function(t) {
      return typeof t == "function";
    }, w = { window: function(t) {
      return t === H || k(t);
    }, docFrag: function(t) {
      return V(t) && t.nodeType === 11;
    }, object: V, func: le, number: function(t) {
      return typeof t == "number";
    }, bool: function(t) {
      return typeof t == "boolean";
    }, string: function(t) {
      return typeof t == "string";
    }, element: function(t) {
      if (!t || v(t) !== "object") return !1;
      var e = B(t) || H;
      return /object|function/.test(typeof Element > "u" ? "undefined" : v(Element)) ? t instanceof Element || t instanceof e.Element : t.nodeType === 1 && typeof t.nodeName == "string";
    }, plainObject: function(t) {
      return V(t) && !!t.constructor && /function Object\b/.test(t.constructor.toString());
    }, array: function(t) {
      return V(t) && t.length !== void 0 && le(t.splice);
    } };
    function ce(t) {
      var e = t.interaction;
      if (e.prepared.name === "drag") {
        var r = e.prepared.axis;
        r === "x" ? (e.coords.cur.page.y = e.coords.start.page.y, e.coords.cur.client.y = e.coords.start.client.y, e.coords.velocity.client.y = 0, e.coords.velocity.page.y = 0) : r === "y" && (e.coords.cur.page.x = e.coords.start.page.x, e.coords.cur.client.x = e.coords.start.client.x, e.coords.velocity.client.x = 0, e.coords.velocity.page.x = 0);
      }
    }
    function Me(t) {
      var e = t.iEvent, r = t.interaction;
      if (r.prepared.name === "drag") {
        var n = r.prepared.axis;
        if (n === "x" || n === "y") {
          var o = n === "x" ? "y" : "x";
          e.page[o] = r.coords.start.page[o], e.client[o] = r.coords.start.client[o], e.delta[o] = 0;
        }
      }
    }
    var nt = { id: "actions/drag", install: function(t) {
      var e = t.actions, r = t.Interactable, n = t.defaults;
      r.prototype.draggable = nt.draggable, e.map.drag = nt, e.methodDict.drag = "draggable", n.actions.drag = nt.defaults;
    }, listeners: { "interactions:before-action-move": ce, "interactions:action-resume": ce, "interactions:action-move": Me, "auto-start:check": function(t) {
      var e = t.interaction, r = t.interactable, n = t.buttons, o = r.options.drag;
      if (o && o.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || n & r.options.drag.mouseButtons)) return t.action = { name: "drag", axis: o.lockAxis === "start" ? o.startAxis : o.lockAxis }, !1;
    } }, draggable: function(t) {
      return w.object(t) ? (this.options.drag.enabled = t.enabled !== !1, this.setPerAction("drag", t), this.setOnEvents("drag", t), /^(xy|x|y|start)$/.test(t.lockAxis) && (this.options.drag.lockAxis = t.lockAxis), /^(xy|x|y)$/.test(t.startAxis) && (this.options.drag.startAxis = t.startAxis), this) : w.bool(t) ? (this.options.drag.enabled = t, this) : this.options.drag;
    }, beforeMove: ce, move: Me, defaults: { startAxis: "xy", lockAxis: "xy" }, getCursor: function() {
      return "move";
    }, filterEventType: function(t) {
      return t.search("drag") === 0;
    } }, Fr = nt, ne = { init: function(t) {
      var e = t;
      ne.document = e.document, ne.DocumentFragment = e.DocumentFragment || Re, ne.SVGElement = e.SVGElement || Re, ne.SVGSVGElement = e.SVGSVGElement || Re, ne.SVGElementInstance = e.SVGElementInstance || Re, ne.Element = e.Element || Re, ne.HTMLElement = e.HTMLElement || ne.Element, ne.Event = e.Event, ne.Touch = e.Touch || Re, ne.PointerEvent = e.PointerEvent || e.MSPointerEvent;
    }, document: null, DocumentFragment: null, SVGElement: null, SVGSVGElement: null, SVGElementInstance: null, Element: null, HTMLElement: null, Event: null, Touch: null, PointerEvent: null };
    function Re() {
    }
    var Q = ne, ie = { init: function(t) {
      var e = Q.Element, r = t.navigator || {};
      ie.supportsTouch = "ontouchstart" in t || w.func(t.DocumentTouch) && Q.document instanceof t.DocumentTouch, ie.supportsPointerEvent = r.pointerEnabled !== !1 && !!Q.PointerEvent, ie.isIOS = /iP(hone|od|ad)/.test(r.platform), ie.isIOS7 = /iP(hone|od|ad)/.test(r.platform) && /OS 7[^\d]/.test(r.appVersion), ie.isIe9 = /MSIE 9/.test(r.userAgent), ie.isOperaMobile = r.appName === "Opera" && ie.supportsTouch && /Presto/.test(r.userAgent), ie.prefixedMatchesSelector = "matches" in e.prototype ? "matches" : "webkitMatchesSelector" in e.prototype ? "webkitMatchesSelector" : "mozMatchesSelector" in e.prototype ? "mozMatchesSelector" : "oMatchesSelector" in e.prototype ? "oMatchesSelector" : "msMatchesSelector", ie.pEventTypes = ie.supportsPointerEvent ? Q.PointerEvent === t.MSPointerEvent ? { up: "MSPointerUp", down: "MSPointerDown", over: "mouseover", out: "mouseout", move: "MSPointerMove", cancel: "MSPointerCancel" } : { up: "pointerup", down: "pointerdown", over: "pointerover", out: "pointerout", move: "pointermove", cancel: "pointercancel" } : null, ie.wheelEvent = Q.document && "onmousewheel" in Q.document ? "mousewheel" : "wheel";
    }, supportsTouch: null, supportsPointerEvent: null, isIOS7: null, isIOS: null, isIe9: null, isOperaMobile: null, prefixedMatchesSelector: null, pEventTypes: null, wheelEvent: null }, oe = ie;
    function Se(t, e) {
      if (t.contains) return t.contains(e);
      for (; e; ) {
        if (e === t) return !0;
        e = e.parentNode;
      }
      return !1;
    }
    function Ur(t, e) {
      for (; w.element(t); ) {
        if (me(t, e)) return t;
        t = pe(t);
      }
      return null;
    }
    function pe(t) {
      var e = t.parentNode;
      if (w.docFrag(e)) {
        for (; (e = e.host) && w.docFrag(e); ) ;
        return e;
      }
      return e;
    }
    function me(t, e) {
      return H !== L && (e = e.replace(/\/deep\//g, " ")), t[oe.prefixedMatchesSelector](e);
    }
    var Wt = function(t) {
      return t.parentNode || t.host;
    };
    function Nr(t, e) {
      for (var r, n = [], o = t; (r = Wt(o)) && o !== e && r !== o.ownerDocument; ) n.unshift(o), o = r;
      return n;
    }
    function Ft(t, e, r) {
      for (; w.element(t); ) {
        if (me(t, e)) return !0;
        if ((t = pe(t)) === r) return me(t, e);
      }
      return !1;
    }
    function Gr(t) {
      return t.correspondingUseElement || t;
    }
    function Ut(t) {
      var e = t instanceof Q.SVGElement ? t.getBoundingClientRect() : t.getClientRects()[0];
      return e && { left: e.left, right: e.right, top: e.top, bottom: e.bottom, width: e.width || e.right - e.left, height: e.height || e.bottom - e.top };
    }
    function Nt(t) {
      var e, r = Ut(t);
      if (!oe.isIOS7 && r) {
        var n = { x: (e = (e = B(t)) || H).scrollX || e.document.documentElement.scrollLeft, y: e.scrollY || e.document.documentElement.scrollTop };
        r.left += n.x, r.right += n.x, r.top += n.y, r.bottom += n.y;
      }
      return r;
    }
    function Yr(t) {
      for (var e = []; t; ) e.push(t), t = pe(t);
      return e;
    }
    function Kr(t) {
      return !!w.string(t) && (Q.document.querySelector(t), !0);
    }
    function W(t, e) {
      for (var r in e) t[r] = e[r];
      return t;
    }
    function Xr(t, e, r) {
      return t === "parent" ? pe(r) : t === "self" ? e.getRect(r) : Ur(r, t);
    }
    function Ue(t, e, r, n) {
      var o = t;
      return w.string(o) ? o = Xr(o, e, r) : w.func(o) && (o = o.apply(void 0, n)), w.element(o) && (o = Nt(o)), o;
    }
    function it(t) {
      return t && { x: "x" in t ? t.x : t.left, y: "y" in t ? t.y : t.top };
    }
    function Gt(t) {
      return !t || "x" in t && "y" in t || ((t = W({}, t)).x = t.left || 0, t.y = t.top || 0, t.width = t.width || (t.right || 0) - t.x, t.height = t.height || (t.bottom || 0) - t.y), t;
    }
    function ot(t, e, r) {
      t.left && (e.left += r.x), t.right && (e.right += r.x), t.top && (e.top += r.y), t.bottom && (e.bottom += r.y), e.width = e.right - e.left, e.height = e.bottom - e.top;
    }
    function Ne(t, e, r) {
      var n = r && t.options[r];
      return it(Ue(n && n.origin || t.options.origin, t, e, [t && e])) || { x: 0, y: 0 };
    }
    function Oe(t, e) {
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function(h) {
        return !0;
      }, n = arguments.length > 3 ? arguments[3] : void 0;
      if (n = n || {}, w.string(t) && t.search(" ") !== -1 && (t = Br(t)), w.array(t)) return t.forEach(function(h) {
        return Oe(h, e, r, n);
      }), n;
      if (w.object(t) && (e = t, t = ""), w.func(e) && r(t)) n[t] = n[t] || [], n[t].push(e);
      else if (w.array(e)) for (var o = 0, l = e; o < l.length; o++) {
        var c = l[o];
        Oe(t, c, r, n);
      }
      else if (w.object(e)) for (var p in e)
        Oe(Br(p).map(function(h) {
          return "".concat(t).concat(h);
        }), e[p], r, n);
      return n;
    }
    function Br(t) {
      return t.trim().split(/ +/);
    }
    var Ge = function(t, e) {
      return Math.sqrt(t * t + e * e);
    }, so = ["webkit", "moz"];
    function st(t, e) {
      t.__set || (t.__set = {});
      var r = function(o) {
        if (so.some(function(l) {
          return o.indexOf(l) === 0;
        })) return 1;
        typeof t[o] != "function" && o !== "__set" && Object.defineProperty(t, o, { get: function() {
          return o in t.__set ? t.__set[o] : t.__set[o] = e[o];
        }, set: function(l) {
          t.__set[o] = l;
        }, configurable: !0 });
      };
      for (var n in e) r(n);
      return t;
    }
    function at(t, e) {
      t.page = t.page || {}, t.page.x = e.page.x, t.page.y = e.page.y, t.client = t.client || {}, t.client.x = e.client.x, t.client.y = e.client.y, t.timeStamp = e.timeStamp;
    }
    function Vr(t) {
      t.page.x = 0, t.page.y = 0, t.client.x = 0, t.client.y = 0;
    }
    function qr(t) {
      return t instanceof Q.Event || t instanceof Q.Touch;
    }
    function lt(t, e, r) {
      return t = t || "page", (r = r || {}).x = e[t + "X"], r.y = e[t + "Y"], r;
    }
    function Zr(t, e) {
      return e = e || { x: 0, y: 0 }, oe.isOperaMobile && qr(t) ? (lt("screen", t, e), e.x += window.scrollX, e.y += window.scrollY) : lt("page", t, e), e;
    }
    function Ye(t) {
      return w.number(t.pointerId) ? t.pointerId : t.identifier;
    }
    function ao(t, e, r) {
      var n = e.length > 1 ? Jr(e) : e[0];
      Zr(n, t.page), function(o, l) {
        l = l || {}, oe.isOperaMobile && qr(o) ? lt("screen", o, l) : lt("client", o, l);
      }(n, t.client), t.timeStamp = r;
    }
    function Yt(t) {
      var e = [];
      return w.array(t) ? (e[0] = t[0], e[1] = t[1]) : t.type === "touchend" ? t.touches.length === 1 ? (e[0] = t.touches[0], e[1] = t.changedTouches[0]) : t.touches.length === 0 && (e[0] = t.changedTouches[0], e[1] = t.changedTouches[1]) : (e[0] = t.touches[0], e[1] = t.touches[1]), e;
    }
    function Jr(t) {
      for (var e = { pageX: 0, pageY: 0, clientX: 0, clientY: 0, screenX: 0, screenY: 0 }, r = 0; r < t.length; r++) {
        var n = t[r];
        for (var o in e) e[o] += n[o];
      }
      for (var l in e) e[l] /= t.length;
      return e;
    }
    function Kt(t) {
      if (!t.length) return null;
      var e = Yt(t), r = Math.min(e[0].pageX, e[1].pageX), n = Math.min(e[0].pageY, e[1].pageY), o = Math.max(e[0].pageX, e[1].pageX), l = Math.max(e[0].pageY, e[1].pageY);
      return { x: r, y: n, left: r, top: n, right: o, bottom: l, width: o - r, height: l - n };
    }
    function Xt(t, e) {
      var r = e + "X", n = e + "Y", o = Yt(t), l = o[0][r] - o[1][r], c = o[0][n] - o[1][n];
      return Ge(l, c);
    }
    function Bt(t, e) {
      var r = e + "X", n = e + "Y", o = Yt(t), l = o[1][r] - o[0][r], c = o[1][n] - o[0][n];
      return 180 * Math.atan2(c, l) / Math.PI;
    }
    function Qr(t) {
      return w.string(t.pointerType) ? t.pointerType : w.number(t.pointerType) ? [void 0, void 0, "touch", "pen", "mouse"][t.pointerType] : /touch/.test(t.type || "") || t instanceof Q.Touch ? "touch" : "mouse";
    }
    function en(t) {
      var e = w.func(t.composedPath) ? t.composedPath() : t.path;
      return [Gr(e ? e[0] : t.target), Gr(t.currentTarget)];
    }
    var ct = function() {
      function t(e) {
        f(this, t), this.immediatePropagationStopped = !1, this.propagationStopped = !1, this._interaction = e;
      }
      return y(t, [{ key: "preventDefault", value: function() {
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = !0;
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = !0;
      } }]), t;
    }();
    Object.defineProperty(ct.prototype, "interaction", { get: function() {
      return this._interaction._proxy;
    }, set: function() {
    } });
    var tn = function(t, e) {
      for (var r = 0; r < e.length; r++) {
        var n = e[r];
        t.push(n);
      }
      return t;
    }, rn = function(t) {
      return tn([], t);
    }, Ke = function(t, e) {
      for (var r = 0; r < t.length; r++) if (e(t[r], r, t)) return r;
      return -1;
    }, Xe = function(t, e) {
      return t[Ke(t, e)];
    }, De = function(t) {
      C(r, t);
      var e = P(r);
      function r(n, o, l) {
        var c;
        f(this, r), (c = e.call(this, o._interaction)).dropzone = void 0, c.dragEvent = void 0, c.relatedTarget = void 0, c.draggable = void 0, c.propagationStopped = !1, c.immediatePropagationStopped = !1;
        var p = l === "dragleave" ? n.prev : n.cur, h = p.element, g = p.dropzone;
        return c.type = l, c.target = h, c.currentTarget = h, c.dropzone = g, c.dragEvent = o, c.relatedTarget = o.target, c.draggable = o.interactable, c.timeStamp = o.timeStamp, c;
      }
      return y(r, [{ key: "reject", value: function() {
        var n = this, o = this._interaction.dropState;
        if (this.type === "dropactivate" || this.dropzone && o.cur.dropzone === this.dropzone && o.cur.element === this.target) if (o.prev.dropzone = this.dropzone, o.prev.element = this.target, o.rejected = !0, o.events.enter = null, this.stopImmediatePropagation(), this.type === "dropactivate") {
          var l = o.activeDrops, c = Ke(l, function(h) {
            var g = h.dropzone, d = h.element;
            return g === n.dropzone && d === n.target;
          });
          o.activeDrops.splice(c, 1);
          var p = new r(o, this.dragEvent, "dropdeactivate");
          p.dropzone = this.dropzone, p.target = this.target, this.dropzone.fire(p);
        } else this.dropzone.fire(new r(o, this.dragEvent, "dragleave"));
      } }, { key: "preventDefault", value: function() {
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = !0;
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = !0;
      } }]), r;
    }(ct);
    function nn(t, e) {
      for (var r = 0, n = t.slice(); r < n.length; r++) {
        var o = n[r], l = o.dropzone, c = o.element;
        e.dropzone = l, e.target = c, l.fire(e), e.propagationStopped = e.immediatePropagationStopped = !1;
      }
    }
    function Vt(t, e) {
      for (var r = function(l, c) {
        for (var p = [], h = 0, g = l.interactables.list; h < g.length; h++) {
          var d = g[h];
          if (d.options.drop.enabled) {
            var b = d.options.drop.accept;
            if (!(w.element(b) && b !== c || w.string(b) && !me(c, b) || w.func(b) && !b({ dropzone: d, draggableElement: c }))) for (var x = 0, I = d.getAllElements(); x < I.length; x++) {
              var E = I[x];
              E !== c && p.push({ dropzone: d, element: E, rect: d.getRect(E) });
            }
          }
        }
        return p;
      }(t, e), n = 0; n < r.length; n++) {
        var o = r[n];
        o.rect = o.dropzone.getRect(o.element);
      }
      return r;
    }
    function on(t, e, r) {
      for (var n = t.dropState, o = t.interactable, l = t.element, c = [], p = 0, h = n.activeDrops; p < h.length; p++) {
        var g = h[p], d = g.dropzone, b = g.element, x = g.rect, I = d.dropCheck(e, r, o, l, b, x);
        c.push(I ? b : null);
      }
      var E = function(M) {
        for (var $, z, A, N = [], K = 0; K < M.length; K++) {
          var F = M[K], G = M[$];
          if (F && K !== $) if (G) {
            var te = Wt(F), J = Wt(G);
            if (te !== F.ownerDocument) if (J !== F.ownerDocument) if (te !== J) {
              N = N.length ? N : Nr(G);
              var re = void 0;
              if (G instanceof Q.HTMLElement && F instanceof Q.SVGElement && !(F instanceof Q.SVGSVGElement)) {
                if (F === J) continue;
                re = F.ownerSVGElement;
              } else re = F;
              for (var se = Nr(re, G.ownerDocument), fe = 0; se[fe] && se[fe] === N[fe]; ) fe++;
              var bt = [se[fe - 1], se[fe], N[fe]];
              if (bt[0]) for (var Qe = bt[0].lastChild; Qe; ) {
                if (Qe === bt[1]) {
                  $ = K, N = se;
                  break;
                }
                if (Qe === bt[2]) break;
                Qe = Qe.previousSibling;
              }
            } else A = G, (parseInt(B(z = F).getComputedStyle(z).zIndex, 10) || 0) >= (parseInt(B(A).getComputedStyle(A).zIndex, 10) || 0) && ($ = K);
            else $ = K;
          } else $ = K;
        }
        return $;
      }(c);
      return n.activeDrops[E] || null;
    }
    function qt(t, e, r) {
      var n = t.dropState, o = { enter: null, leave: null, activate: null, deactivate: null, move: null, drop: null };
      return r.type === "dragstart" && (o.activate = new De(n, r, "dropactivate"), o.activate.target = null, o.activate.dropzone = null), r.type === "dragend" && (o.deactivate = new De(n, r, "dropdeactivate"), o.deactivate.target = null, o.deactivate.dropzone = null), n.rejected || (n.cur.element !== n.prev.element && (n.prev.dropzone && (o.leave = new De(n, r, "dragleave"), r.dragLeave = o.leave.target = n.prev.element, r.prevDropzone = o.leave.dropzone = n.prev.dropzone), n.cur.dropzone && (o.enter = new De(n, r, "dragenter"), r.dragEnter = n.cur.element, r.dropzone = n.cur.dropzone)), r.type === "dragend" && n.cur.dropzone && (o.drop = new De(n, r, "drop"), r.dropzone = n.cur.dropzone, r.relatedTarget = n.cur.element), r.type === "dragmove" && n.cur.dropzone && (o.move = new De(n, r, "dropmove"), r.dropzone = n.cur.dropzone)), o;
    }
    function Zt(t, e) {
      var r = t.dropState, n = r.activeDrops, o = r.cur, l = r.prev;
      e.leave && l.dropzone.fire(e.leave), e.enter && o.dropzone.fire(e.enter), e.move && o.dropzone.fire(e.move), e.drop && o.dropzone.fire(e.drop), e.deactivate && nn(n, e.deactivate), r.prev.dropzone = o.dropzone, r.prev.element = o.element;
    }
    function sn(t, e) {
      var r = t.interaction, n = t.iEvent, o = t.event;
      if (n.type === "dragmove" || n.type === "dragend") {
        var l = r.dropState;
        e.dynamicDrop && (l.activeDrops = Vt(e, r.element));
        var c = n, p = on(r, c, o);
        l.rejected = l.rejected && !!p && p.dropzone === l.cur.dropzone && p.element === l.cur.element, l.cur.dropzone = p && p.dropzone, l.cur.element = p && p.element, l.events = qt(r, 0, c);
      }
    }
    var an = { id: "actions/drop", install: function(t) {
      var e = t.actions, r = t.interactStatic, n = t.Interactable, o = t.defaults;
      t.usePlugin(Fr), n.prototype.dropzone = function(l) {
        return function(c, p) {
          if (w.object(p)) {
            if (c.options.drop.enabled = p.enabled !== !1, p.listeners) {
              var h = Oe(p.listeners), g = Object.keys(h).reduce(function(b, x) {
                return b[/^(enter|leave)/.test(x) ? "drag".concat(x) : /^(activate|deactivate|move)/.test(x) ? "drop".concat(x) : x] = h[x], b;
              }, {}), d = c.options.drop.listeners;
              d && c.off(d), c.on(g), c.options.drop.listeners = g;
            }
            return w.func(p.ondrop) && c.on("drop", p.ondrop), w.func(p.ondropactivate) && c.on("dropactivate", p.ondropactivate), w.func(p.ondropdeactivate) && c.on("dropdeactivate", p.ondropdeactivate), w.func(p.ondragenter) && c.on("dragenter", p.ondragenter), w.func(p.ondragleave) && c.on("dragleave", p.ondragleave), w.func(p.ondropmove) && c.on("dropmove", p.ondropmove), /^(pointer|center)$/.test(p.overlap) ? c.options.drop.overlap = p.overlap : w.number(p.overlap) && (c.options.drop.overlap = Math.max(Math.min(1, p.overlap), 0)), "accept" in p && (c.options.drop.accept = p.accept), "checker" in p && (c.options.drop.checker = p.checker), c;
          }
          return w.bool(p) ? (c.options.drop.enabled = p, c) : c.options.drop;
        }(this, l);
      }, n.prototype.dropCheck = function(l, c, p, h, g, d) {
        return function(b, x, I, E, M, $, z) {
          var A = !1;
          if (!(z = z || b.getRect($))) return !!b.options.drop.checker && b.options.drop.checker(x, I, A, b, $, E, M);
          var N = b.options.drop.overlap;
          if (N === "pointer") {
            var K = Ne(E, M, "drag"), F = Zr(x);
            F.x += K.x, F.y += K.y;
            var G = F.x > z.left && F.x < z.right, te = F.y > z.top && F.y < z.bottom;
            A = G && te;
          }
          var J = E.getRect(M);
          if (J && N === "center") {
            var re = J.left + J.width / 2, se = J.top + J.height / 2;
            A = re >= z.left && re <= z.right && se >= z.top && se <= z.bottom;
          }
          return J && w.number(N) && (A = Math.max(0, Math.min(z.right, J.right) - Math.max(z.left, J.left)) * Math.max(0, Math.min(z.bottom, J.bottom) - Math.max(z.top, J.top)) / (J.width * J.height) >= N), b.options.drop.checker && (A = b.options.drop.checker(x, I, A, b, $, E, M)), A;
        }(this, l, c, p, h, g, d);
      }, r.dynamicDrop = function(l) {
        return w.bool(l) ? (t.dynamicDrop = l, r) : t.dynamicDrop;
      }, W(e.phaselessTypes, { dragenter: !0, dragleave: !0, dropactivate: !0, dropdeactivate: !0, dropmove: !0, drop: !0 }), e.methodDict.drop = "dropzone", t.dynamicDrop = !1, o.actions.drop = an.defaults;
    }, listeners: { "interactions:before-action-start": function(t) {
      var e = t.interaction;
      e.prepared.name === "drag" && (e.dropState = { cur: { dropzone: null, element: null }, prev: { dropzone: null, element: null }, rejected: null, events: null, activeDrops: [] });
    }, "interactions:after-action-start": function(t, e) {
      var r = t.interaction, n = (t.event, t.iEvent);
      if (r.prepared.name === "drag") {
        var o = r.dropState;
        o.activeDrops = [], o.events = {}, o.activeDrops = Vt(e, r.element), o.events = qt(r, 0, n), o.events.activate && (nn(o.activeDrops, o.events.activate), e.fire("actions/drop:start", { interaction: r, dragEvent: n }));
      }
    }, "interactions:action-move": sn, "interactions:after-action-move": function(t, e) {
      var r = t.interaction, n = t.iEvent;
      if (r.prepared.name === "drag") {
        var o = r.dropState;
        Zt(r, o.events), e.fire("actions/drop:move", { interaction: r, dragEvent: n }), o.events = {};
      }
    }, "interactions:action-end": function(t, e) {
      if (t.interaction.prepared.name === "drag") {
        var r = t.interaction, n = t.iEvent;
        sn(t, e), Zt(r, r.dropState.events), e.fire("actions/drop:end", { interaction: r, dragEvent: n });
      }
    }, "interactions:stop": function(t) {
      var e = t.interaction;
      if (e.prepared.name === "drag") {
        var r = e.dropState;
        r && (r.activeDrops = null, r.events = null, r.cur.dropzone = null, r.cur.element = null, r.prev.dropzone = null, r.prev.element = null, r.rejected = !1);
      }
    } }, getActiveDrops: Vt, getDrop: on, getDropEvents: qt, fireDropEvents: Zt, filterEventType: function(t) {
      return t.search("drag") === 0 || t.search("drop") === 0;
    }, defaults: { enabled: !1, accept: null, overlap: "pointer" } }, lo = an;
    function Jt(t) {
      var e = t.interaction, r = t.iEvent, n = t.phase;
      if (e.prepared.name === "gesture") {
        var o = e.pointers.map(function(g) {
          return g.pointer;
        }), l = n === "start", c = n === "end", p = e.interactable.options.deltaSource;
        if (r.touches = [o[0], o[1]], l) r.distance = Xt(o, p), r.box = Kt(o), r.scale = 1, r.ds = 0, r.angle = Bt(o, p), r.da = 0, e.gesture.startDistance = r.distance, e.gesture.startAngle = r.angle;
        else if (c || e.pointers.length < 2) {
          var h = e.prevEvent;
          r.distance = h.distance, r.box = h.box, r.scale = h.scale, r.ds = 0, r.angle = h.angle, r.da = 0;
        } else r.distance = Xt(o, p), r.box = Kt(o), r.scale = r.distance / e.gesture.startDistance, r.angle = Bt(o, p), r.ds = r.scale - e.gesture.scale, r.da = r.angle - e.gesture.angle;
        e.gesture.distance = r.distance, e.gesture.angle = r.angle, w.number(r.scale) && r.scale !== 1 / 0 && !isNaN(r.scale) && (e.gesture.scale = r.scale);
      }
    }
    var Qt = { id: "actions/gesture", before: ["actions/drag", "actions/resize"], install: function(t) {
      var e = t.actions, r = t.Interactable, n = t.defaults;
      r.prototype.gesturable = function(o) {
        return w.object(o) ? (this.options.gesture.enabled = o.enabled !== !1, this.setPerAction("gesture", o), this.setOnEvents("gesture", o), this) : w.bool(o) ? (this.options.gesture.enabled = o, this) : this.options.gesture;
      }, e.map.gesture = Qt, e.methodDict.gesture = "gesturable", n.actions.gesture = Qt.defaults;
    }, listeners: { "interactions:action-start": Jt, "interactions:action-move": Jt, "interactions:action-end": Jt, "interactions:new": function(t) {
      t.interaction.gesture = { angle: 0, distance: 0, scale: 1, startAngle: 0, startDistance: 0 };
    }, "auto-start:check": function(t) {
      if (!(t.interaction.pointers.length < 2)) {
        var e = t.interactable.options.gesture;
        if (e && e.enabled) return t.action = { name: "gesture" }, !1;
      }
    } }, defaults: {}, getCursor: function() {
      return "";
    }, filterEventType: function(t) {
      return t.search("gesture") === 0;
    } }, co = Qt;
    function uo(t, e, r, n, o, l, c) {
      if (!e) return !1;
      if (e === !0) {
        var p = w.number(l.width) ? l.width : l.right - l.left, h = w.number(l.height) ? l.height : l.bottom - l.top;
        if (c = Math.min(c, Math.abs((t === "left" || t === "right" ? p : h) / 2)), p < 0 && (t === "left" ? t = "right" : t === "right" && (t = "left")), h < 0 && (t === "top" ? t = "bottom" : t === "bottom" && (t = "top")), t === "left") {
          var g = p >= 0 ? l.left : l.right;
          return r.x < g + c;
        }
        if (t === "top") {
          var d = h >= 0 ? l.top : l.bottom;
          return r.y < d + c;
        }
        if (t === "right") return r.x > (p >= 0 ? l.right : l.left) - c;
        if (t === "bottom") return r.y > (h >= 0 ? l.bottom : l.top) - c;
      }
      return !!w.element(n) && (w.element(e) ? e === n : Ft(n, e, o));
    }
    function ln(t) {
      var e = t.iEvent, r = t.interaction;
      if (r.prepared.name === "resize" && r.resizeAxes) {
        var n = e;
        r.interactable.options.resize.square ? (r.resizeAxes === "y" ? n.delta.x = n.delta.y : n.delta.y = n.delta.x, n.axes = "xy") : (n.axes = r.resizeAxes, r.resizeAxes === "x" ? n.delta.y = 0 : r.resizeAxes === "y" && (n.delta.x = 0));
      }
    }
    var he, Ce, de = { id: "actions/resize", before: ["actions/drag"], install: function(t) {
      var e = t.actions, r = t.browser, n = t.Interactable, o = t.defaults;
      de.cursors = function(l) {
        return l.isIe9 ? { x: "e-resize", y: "s-resize", xy: "se-resize", top: "n-resize", left: "w-resize", bottom: "s-resize", right: "e-resize", topleft: "se-resize", bottomright: "se-resize", topright: "ne-resize", bottomleft: "ne-resize" } : { x: "ew-resize", y: "ns-resize", xy: "nwse-resize", top: "ns-resize", left: "ew-resize", bottom: "ns-resize", right: "ew-resize", topleft: "nwse-resize", bottomright: "nwse-resize", topright: "nesw-resize", bottomleft: "nesw-resize" };
      }(r), de.defaultMargin = r.supportsTouch || r.supportsPointerEvent ? 20 : 10, n.prototype.resizable = function(l) {
        return function(c, p, h) {
          return w.object(p) ? (c.options.resize.enabled = p.enabled !== !1, c.setPerAction("resize", p), c.setOnEvents("resize", p), w.string(p.axis) && /^x$|^y$|^xy$/.test(p.axis) ? c.options.resize.axis = p.axis : p.axis === null && (c.options.resize.axis = h.defaults.actions.resize.axis), w.bool(p.preserveAspectRatio) ? c.options.resize.preserveAspectRatio = p.preserveAspectRatio : w.bool(p.square) && (c.options.resize.square = p.square), c) : w.bool(p) ? (c.options.resize.enabled = p, c) : c.options.resize;
        }(this, l, t);
      }, e.map.resize = de, e.methodDict.resize = "resizable", o.actions.resize = de.defaults;
    }, listeners: { "interactions:new": function(t) {
      t.interaction.resizeAxes = "xy";
    }, "interactions:action-start": function(t) {
      (function(e) {
        var r = e.iEvent, n = e.interaction;
        if (n.prepared.name === "resize" && n.prepared.edges) {
          var o = r, l = n.rect;
          n._rects = { start: W({}, l), corrected: W({}, l), previous: W({}, l), delta: { left: 0, right: 0, width: 0, top: 0, bottom: 0, height: 0 } }, o.edges = n.prepared.edges, o.rect = n._rects.corrected, o.deltaRect = n._rects.delta;
        }
      })(t), ln(t);
    }, "interactions:action-move": function(t) {
      (function(e) {
        var r = e.iEvent, n = e.interaction;
        if (n.prepared.name === "resize" && n.prepared.edges) {
          var o = r, l = n.interactable.options.resize.invert, c = l === "reposition" || l === "negate", p = n.rect, h = n._rects, g = h.start, d = h.corrected, b = h.delta, x = h.previous;
          if (W(x, d), c) {
            if (W(d, p), l === "reposition") {
              if (d.top > d.bottom) {
                var I = d.top;
                d.top = d.bottom, d.bottom = I;
              }
              if (d.left > d.right) {
                var E = d.left;
                d.left = d.right, d.right = E;
              }
            }
          } else d.top = Math.min(p.top, g.bottom), d.bottom = Math.max(p.bottom, g.top), d.left = Math.min(p.left, g.right), d.right = Math.max(p.right, g.left);
          for (var M in d.width = d.right - d.left, d.height = d.bottom - d.top, d) b[M] = d[M] - x[M];
          o.edges = n.prepared.edges, o.rect = d, o.deltaRect = b;
        }
      })(t), ln(t);
    }, "interactions:action-end": function(t) {
      var e = t.iEvent, r = t.interaction;
      if (r.prepared.name === "resize" && r.prepared.edges) {
        var n = e;
        n.edges = r.prepared.edges, n.rect = r._rects.corrected, n.deltaRect = r._rects.delta;
      }
    }, "auto-start:check": function(t) {
      var e = t.interaction, r = t.interactable, n = t.element, o = t.rect, l = t.buttons;
      if (o) {
        var c = W({}, e.coords.cur.page), p = r.options.resize;
        if (p && p.enabled && (!e.pointerIsDown || !/mouse|pointer/.test(e.pointerType) || l & p.mouseButtons)) {
          if (w.object(p.edges)) {
            var h = { left: !1, right: !1, top: !1, bottom: !1 };
            for (var g in h) h[g] = uo(g, p.edges[g], c, e._latestPointer.eventTarget, n, o, p.margin || de.defaultMargin);
            h.left = h.left && !h.right, h.top = h.top && !h.bottom, (h.left || h.right || h.top || h.bottom) && (t.action = { name: "resize", edges: h });
          } else {
            var d = p.axis !== "y" && c.x > o.right - de.defaultMargin, b = p.axis !== "x" && c.y > o.bottom - de.defaultMargin;
            (d || b) && (t.action = { name: "resize", axes: (d ? "x" : "") + (b ? "y" : "") });
          }
          return !t.action && void 0;
        }
      }
    } }, defaults: { square: !1, preserveAspectRatio: !1, axis: "xy", margin: NaN, edges: null, invert: "none" }, cursors: null, getCursor: function(t) {
      var e = t.edges, r = t.axis, n = t.name, o = de.cursors, l = null;
      if (r) l = o[n + r];
      else if (e) {
        for (var c = "", p = 0, h = ["top", "bottom", "left", "right"]; p < h.length; p++) {
          var g = h[p];
          e[g] && (c += g);
        }
        l = o[c];
      }
      return l;
    }, filterEventType: function(t) {
      return t.search("resize") === 0;
    }, defaultMargin: null }, po = de, ho = { id: "actions", install: function(t) {
      t.usePlugin(co), t.usePlugin(po), t.usePlugin(Fr), t.usePlugin(lo);
    } }, cn = 0, be = { request: function(t) {
      return he(t);
    }, cancel: function(t) {
      return Ce(t);
    }, init: function(t) {
      if (he = t.requestAnimationFrame, Ce = t.cancelAnimationFrame, !he) for (var e = ["ms", "moz", "webkit", "o"], r = 0; r < e.length; r++) {
        var n = e[r];
        he = t["".concat(n, "RequestAnimationFrame")], Ce = t["".concat(n, "CancelAnimationFrame")] || t["".concat(n, "CancelRequestAnimationFrame")];
      }
      he = he && he.bind(t), Ce = Ce && Ce.bind(t), he || (he = function(o) {
        var l = Date.now(), c = Math.max(0, 16 - (l - cn)), p = t.setTimeout(function() {
          o(l + c);
        }, c);
        return cn = l + c, p;
      }, Ce = function(o) {
        return clearTimeout(o);
      });
    } }, U = { defaults: { enabled: !1, margin: 60, container: null, speed: 300 }, now: Date.now, interaction: null, i: 0, x: 0, y: 0, isScrolling: !1, prevTime: 0, margin: 0, speed: 0, start: function(t) {
      U.isScrolling = !0, be.cancel(U.i), t.autoScroll = U, U.interaction = t, U.prevTime = U.now(), U.i = be.request(U.scroll);
    }, stop: function() {
      U.isScrolling = !1, U.interaction && (U.interaction.autoScroll = null), be.cancel(U.i);
    }, scroll: function() {
      var t = U.interaction, e = t.interactable, r = t.element, n = t.prepared.name, o = e.options[n].autoScroll, l = un(o.container, e, r), c = U.now(), p = (c - U.prevTime) / 1e3, h = o.speed * p;
      if (h >= 1) {
        var g = { x: U.x * h, y: U.y * h };
        if (g.x || g.y) {
          var d = pn(l);
          w.window(l) ? l.scrollBy(g.x, g.y) : l && (l.scrollLeft += g.x, l.scrollTop += g.y);
          var b = pn(l), x = { x: b.x - d.x, y: b.y - d.y };
          (x.x || x.y) && e.fire({ type: "autoscroll", target: r, interactable: e, delta: x, interaction: t, container: l });
        }
        U.prevTime = c;
      }
      U.isScrolling && (be.cancel(U.i), U.i = be.request(U.scroll));
    }, check: function(t, e) {
      var r;
      return (r = t.options[e].autoScroll) == null ? void 0 : r.enabled;
    }, onInteractionMove: function(t) {
      var e = t.interaction, r = t.pointer;
      if (e.interacting() && U.check(e.interactable, e.prepared.name)) if (e.simulation) U.x = U.y = 0;
      else {
        var n, o, l, c, p = e.interactable, h = e.element, g = e.prepared.name, d = p.options[g].autoScroll, b = un(d.container, p, h);
        if (w.window(b)) c = r.clientX < U.margin, n = r.clientY < U.margin, o = r.clientX > b.innerWidth - U.margin, l = r.clientY > b.innerHeight - U.margin;
        else {
          var x = Ut(b);
          c = r.clientX < x.left + U.margin, n = r.clientY < x.top + U.margin, o = r.clientX > x.right - U.margin, l = r.clientY > x.bottom - U.margin;
        }
        U.x = o ? 1 : c ? -1 : 0, U.y = l ? 1 : n ? -1 : 0, U.isScrolling || (U.margin = d.margin, U.speed = d.speed, U.start(e));
      }
    } };
    function un(t, e, r) {
      return (w.string(t) ? Xr(t, e, r) : t) || B(r);
    }
    function pn(t) {
      return w.window(t) && (t = window.document.body), { x: t.scrollLeft, y: t.scrollTop };
    }
    var fo = { id: "auto-scroll", install: function(t) {
      var e = t.defaults, r = t.actions;
      t.autoScroll = U, U.now = function() {
        return t.now();
      }, r.phaselessTypes.autoscroll = !0, e.perAction.autoScroll = U.defaults;
    }, listeners: { "interactions:new": function(t) {
      t.interaction.autoScroll = null;
    }, "interactions:destroy": function(t) {
      t.interaction.autoScroll = null, U.stop(), U.interaction && (U.interaction = null);
    }, "interactions:stop": U.stop, "interactions:action-move": function(t) {
      return U.onInteractionMove(t);
    } } }, vo = fo;
    function Be(t, e) {
      var r = !1;
      return function() {
        return r || (H.console.warn(e), r = !0), t.apply(this, arguments);
      };
    }
    function er(t, e) {
      return t.name = e.name, t.axis = e.axis, t.edges = e.edges, t;
    }
    function go(t) {
      return w.bool(t) ? (this.options.styleCursor = t, this) : t === null ? (delete this.options.styleCursor, this) : this.options.styleCursor;
    }
    function mo(t) {
      return w.func(t) ? (this.options.actionChecker = t, this) : t === null ? (delete this.options.actionChecker, this) : this.options.actionChecker;
    }
    var bo = { id: "auto-start/interactableMethods", install: function(t) {
      var e = t.Interactable;
      e.prototype.getAction = function(r, n, o, l) {
        var c = function(p, h, g, d, b) {
          var x = p.getRect(d), I = h.buttons || { 0: 1, 1: 4, 3: 8, 4: 16 }[h.button], E = { action: null, interactable: p, interaction: g, element: d, rect: x, buttons: I };
          return b.fire("auto-start:check", E), E.action;
        }(this, n, o, l, t);
        return this.options.actionChecker ? this.options.actionChecker(r, n, c, this, l, o) : c;
      }, e.prototype.ignoreFrom = Be(function(r) {
        return this._backCompatOption("ignoreFrom", r);
      }, "Interactable.ignoreFrom() has been deprecated. Use Interactble.draggable({ignoreFrom: newValue})."), e.prototype.allowFrom = Be(function(r) {
        return this._backCompatOption("allowFrom", r);
      }, "Interactable.allowFrom() has been deprecated. Use Interactble.draggable({allowFrom: newValue})."), e.prototype.actionChecker = mo, e.prototype.styleCursor = go;
    } };
    function hn(t, e, r, n, o) {
      return e.testIgnoreAllow(e.options[t.name], r, n) && e.options[t.name].enabled && ut(e, r, t, o) ? t : null;
    }
    function yo(t, e, r, n, o, l, c) {
      for (var p = 0, h = n.length; p < h; p++) {
        var g = n[p], d = o[p], b = g.getAction(e, r, t, d);
        if (b) {
          var x = hn(b, g, d, l, c);
          if (x) return { action: x, interactable: g, element: d };
        }
      }
      return { action: null, interactable: null, element: null };
    }
    function dn(t, e, r, n, o) {
      var l = [], c = [], p = n;
      function h(d) {
        l.push(d), c.push(p);
      }
      for (; w.element(p); ) {
        l = [], c = [], o.interactables.forEachMatch(p, h);
        var g = yo(t, e, r, l, c, n, o);
        if (g.action && !g.interactable.options[g.action.name].manualStart) return g;
        p = pe(p);
      }
      return { action: null, interactable: null, element: null };
    }
    function fn(t, e, r) {
      var n = e.action, o = e.interactable, l = e.element;
      n = n || { name: null }, t.interactable = o, t.element = l, er(t.prepared, n), t.rect = o && n.name ? o.getRect(l) : null, gn(t, r), r.fire("autoStart:prepared", { interaction: t });
    }
    function ut(t, e, r, n) {
      var o = t.options, l = o[r.name].max, c = o[r.name].maxPerElement, p = n.autoStart.maxInteractions, h = 0, g = 0, d = 0;
      if (!(l && c && p)) return !1;
      for (var b = 0, x = n.interactions.list; b < x.length; b++) {
        var I = x[b], E = I.prepared.name;
        if (I.interacting() && (++h >= p || I.interactable === t && ((g += E === r.name ? 1 : 0) >= l || I.element === e && (d++, E === r.name && d >= c))))
          return !1;
      }
      return p > 0;
    }
    function vn(t, e) {
      return w.number(t) ? (e.autoStart.maxInteractions = t, this) : e.autoStart.maxInteractions;
    }
    function tr(t, e, r) {
      var n = r.autoStart.cursorElement;
      n && n !== t && (n.style.cursor = ""), t.ownerDocument.documentElement.style.cursor = e, t.style.cursor = e, r.autoStart.cursorElement = e ? t : null;
    }
    function gn(t, e) {
      var r = t.interactable, n = t.element, o = t.prepared;
      if (t.pointerType === "mouse" && r && r.options.styleCursor) {
        var l = "";
        if (o.name) {
          var c = r.options[o.name].cursorChecker;
          l = w.func(c) ? c(o, r, n, t._interacting) : e.actions.map[o.name].getCursor(o);
        }
        tr(t.element, l || "", e);
      } else e.autoStart.cursorElement && tr(e.autoStart.cursorElement, "", e);
    }
    var To = { id: "auto-start/base", before: ["actions"], install: function(t) {
      var e = t.interactStatic, r = t.defaults;
      t.usePlugin(bo), r.base.actionChecker = null, r.base.styleCursor = !0, W(r.perAction, { manualStart: !1, max: 1 / 0, maxPerElement: 1, allowFrom: null, ignoreFrom: null, mouseButtons: 1 }), e.maxInteractions = function(n) {
        return vn(n, t);
      }, t.autoStart = { maxInteractions: 1 / 0, withinInteractionLimit: ut, cursorElement: null };
    }, listeners: { "interactions:down": function(t, e) {
      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget;
      r.interacting() || fn(r, dn(r, n, o, l, e), e);
    }, "interactions:move": function(t, e) {
      (function(r, n) {
        var o = r.interaction, l = r.pointer, c = r.event, p = r.eventTarget;
        o.pointerType !== "mouse" || o.pointerIsDown || o.interacting() || fn(o, dn(o, l, c, p, n), n);
      })(t, e), function(r, n) {
        var o = r.interaction;
        if (o.pointerIsDown && !o.interacting() && o.pointerWasMoved && o.prepared.name) {
          n.fire("autoStart:before-start", r);
          var l = o.interactable, c = o.prepared.name;
          c && l && (l.options[c].manualStart || !ut(l, o.element, o.prepared, n) ? o.stop() : (o.start(o.prepared, l, o.element), gn(o, n)));
        }
      }(t, e);
    }, "interactions:stop": function(t, e) {
      var r = t.interaction, n = r.interactable;
      n && n.options.styleCursor && tr(r.element, "", e);
    } }, maxInteractions: vn, withinInteractionLimit: ut, validateAction: hn }, rr = To, wo = { id: "auto-start/dragAxis", listeners: { "autoStart:before-start": function(t, e) {
      var r = t.interaction, n = t.eventTarget, o = t.dx, l = t.dy;
      if (r.prepared.name === "drag") {
        var c = Math.abs(o), p = Math.abs(l), h = r.interactable.options.drag, g = h.startAxis, d = c > p ? "x" : c < p ? "y" : "xy";
        if (r.prepared.axis = h.lockAxis === "start" ? d[0] : h.lockAxis, d !== "xy" && g !== "xy" && g !== d) {
          r.prepared.name = null;
          for (var b = n, x = function(E) {
            if (E !== r.interactable) {
              var M = r.interactable.options.drag;
              if (!M.manualStart && E.testIgnoreAllow(M, b, n)) {
                var $ = E.getAction(r.downPointer, r.downEvent, r, b);
                if ($ && $.name === "drag" && function(z, A) {
                  if (!A) return !1;
                  var N = A.options.drag.startAxis;
                  return z === "xy" || N === "xy" || N === z;
                }(d, E) && rr.validateAction($, E, b, n, e)) return E;
              }
            }
          }; w.element(b); ) {
            var I = e.interactables.forEachMatch(b, x);
            if (I) {
              r.prepared.name = "drag", r.interactable = I, r.element = b;
              break;
            }
            b = pe(b);
          }
        }
      }
    } } };
    function nr(t) {
      var e = t.prepared && t.prepared.name;
      if (!e) return null;
      var r = t.interactable.options;
      return r[e].hold || r[e].delay;
    }
    var xo = { id: "auto-start/hold", install: function(t) {
      var e = t.defaults;
      t.usePlugin(rr), e.perAction.hold = 0, e.perAction.delay = 0;
    }, listeners: { "interactions:new": function(t) {
      t.interaction.autoStartHoldTimer = null;
    }, "autoStart:prepared": function(t) {
      var e = t.interaction, r = nr(e);
      r > 0 && (e.autoStartHoldTimer = setTimeout(function() {
        e.start(e.prepared, e.interactable, e.element);
      }, r));
    }, "interactions:move": function(t) {
      var e = t.interaction, r = t.duplicate;
      e.autoStartHoldTimer && e.pointerWasMoved && !r && (clearTimeout(e.autoStartHoldTimer), e.autoStartHoldTimer = null);
    }, "autoStart:before-start": function(t) {
      var e = t.interaction;
      nr(e) > 0 && (e.prepared.name = null);
    } }, getHoldDuration: nr }, So = xo, Oo = { id: "auto-start", install: function(t) {
      t.usePlugin(rr), t.usePlugin(So), t.usePlugin(wo);
    } }, Co = function(t) {
      return /^(always|never|auto)$/.test(t) ? (this.options.preventDefault = t, this) : w.bool(t) ? (this.options.preventDefault = t ? "always" : "never", this) : this.options.preventDefault;
    };
    function Eo(t) {
      var e = t.interaction, r = t.event;
      e.interactable && e.interactable.checkAndPreventDefault(r);
    }
    var mn = { id: "core/interactablePreventDefault", install: function(t) {
      var e = t.Interactable;
      e.prototype.preventDefault = Co, e.prototype.checkAndPreventDefault = function(r) {
        return function(n, o, l) {
          var c = n.options.preventDefault;
          if (c !== "never") if (c !== "always") {
            if (o.events.supportsPassive && /^touch(start|move)$/.test(l.type)) {
              var p = B(l.target).document, h = o.getDocOptions(p);
              if (!h || !h.events || h.events.passive !== !1) return;
            }
            /^(mouse|pointer|touch)*(down|start)/i.test(l.type) || w.element(l.target) && me(l.target, "input,select,textarea,[contenteditable=true],[contenteditable=true] *") || l.preventDefault();
          } else l.preventDefault();
        }(this, t, r);
      }, t.interactions.docEvents.push({ type: "dragstart", listener: function(r) {
        for (var n = 0, o = t.interactions.list; n < o.length; n++) {
          var l = o[n];
          if (l.element && (l.element === r.target || Se(l.element, r.target))) return void l.interactable.checkAndPreventDefault(r);
        }
      } });
    }, listeners: ["down", "move", "up", "cancel"].reduce(function(t, e) {
      return t["interactions:".concat(e)] = Eo, t;
    }, {}) };
    function pt(t, e) {
      if (e.phaselessTypes[t]) return !0;
      for (var r in e.map) if (t.indexOf(r) === 0 && t.substr(r.length) in e.phases) return !0;
      return !1;
    }
    function ke(t) {
      var e = {};
      for (var r in t) {
        var n = t[r];
        w.plainObject(n) ? e[r] = ke(n) : w.array(n) ? e[r] = rn(n) : e[r] = n;
      }
      return e;
    }
    var ir = function() {
      function t(e) {
        f(this, t), this.states = [], this.startOffset = { left: 0, right: 0, top: 0, bottom: 0 }, this.startDelta = void 0, this.result = void 0, this.endResult = void 0, this.startEdges = void 0, this.edges = void 0, this.interaction = void 0, this.interaction = e, this.result = ht(), this.edges = { left: !1, right: !1, top: !1, bottom: !1 };
      }
      return y(t, [{ key: "start", value: function(e, r) {
        var n, o, l = e.phase, c = this.interaction, p = function(g) {
          var d = g.interactable.options[g.prepared.name], b = d.modifiers;
          return b && b.length ? b : ["snap", "snapSize", "snapEdges", "restrict", "restrictEdges", "restrictSize"].map(function(x) {
            var I = d[x];
            return I && I.enabled && { options: I, methods: I._methods };
          }).filter(function(x) {
            return !!x;
          });
        }(c);
        this.prepareStates(p), this.startEdges = W({}, c.edges), this.edges = W({}, this.startEdges), this.startOffset = (n = c.rect, o = r, n ? { left: o.x - n.left, top: o.y - n.top, right: n.right - o.x, bottom: n.bottom - o.y } : { left: 0, top: 0, right: 0, bottom: 0 }), this.startDelta = { x: 0, y: 0 };
        var h = this.fillArg({ phase: l, pageCoords: r, preEnd: !1 });
        return this.result = ht(), this.startAll(h), this.result = this.setAll(h);
      } }, { key: "fillArg", value: function(e) {
        var r = this.interaction;
        return e.interaction = r, e.interactable = r.interactable, e.element = r.element, e.rect || (e.rect = r.rect), e.edges || (e.edges = this.startEdges), e.startOffset = this.startOffset, e;
      } }, { key: "startAll", value: function(e) {
        for (var r = 0, n = this.states; r < n.length; r++) {
          var o = n[r];
          o.methods.start && (e.state = o, o.methods.start(e));
        }
      } }, { key: "setAll", value: function(e) {
        var r = e.phase, n = e.preEnd, o = e.skipModifiers, l = e.rect, c = e.edges;
        e.coords = W({}, e.pageCoords), e.rect = W({}, l), e.edges = W({}, c);
        for (var p = o ? this.states.slice(o) : this.states, h = ht(e.coords, e.rect), g = 0; g < p.length; g++) {
          var d, b = p[g], x = b.options, I = W({}, e.coords), E = null;
          (d = b.methods) != null && d.set && this.shouldDo(x, n, r) && (e.state = b, E = b.methods.set(e), ot(e.edges, e.rect, { x: e.coords.x - I.x, y: e.coords.y - I.y })), h.eventProps.push(E);
        }
        W(this.edges, e.edges), h.delta.x = e.coords.x - e.pageCoords.x, h.delta.y = e.coords.y - e.pageCoords.y, h.rectDelta.left = e.rect.left - l.left, h.rectDelta.right = e.rect.right - l.right, h.rectDelta.top = e.rect.top - l.top, h.rectDelta.bottom = e.rect.bottom - l.bottom;
        var M = this.result.coords, $ = this.result.rect;
        if (M && $) {
          var z = h.rect.left !== $.left || h.rect.right !== $.right || h.rect.top !== $.top || h.rect.bottom !== $.bottom;
          h.changed = z || M.x !== h.coords.x || M.y !== h.coords.y;
        }
        return h;
      } }, { key: "applyToInteraction", value: function(e) {
        var r = this.interaction, n = e.phase, o = r.coords.cur, l = r.coords.start, c = this.result, p = this.startDelta, h = c.delta;
        n === "start" && W(this.startDelta, c.delta);
        for (var g = 0, d = [[l, p], [o, h]]; g < d.length; g++) {
          var b = d[g], x = b[0], I = b[1];
          x.page.x += I.x, x.page.y += I.y, x.client.x += I.x, x.client.y += I.y;
        }
        var E = this.result.rectDelta, M = e.rect || r.rect;
        M.left += E.left, M.right += E.right, M.top += E.top, M.bottom += E.bottom, M.width = M.right - M.left, M.height = M.bottom - M.top;
      } }, { key: "setAndApply", value: function(e) {
        var r = this.interaction, n = e.phase, o = e.preEnd, l = e.skipModifiers, c = this.setAll(this.fillArg({ preEnd: o, phase: n, pageCoords: e.modifiedCoords || r.coords.cur.page }));
        if (this.result = c, !c.changed && (!l || l < this.states.length) && r.interacting()) return !1;
        if (e.modifiedCoords) {
          var p = r.coords.cur.page, h = { x: e.modifiedCoords.x - p.x, y: e.modifiedCoords.y - p.y };
          c.coords.x += h.x, c.coords.y += h.y, c.delta.x += h.x, c.delta.y += h.y;
        }
        this.applyToInteraction(e);
      } }, { key: "beforeEnd", value: function(e) {
        var r = e.interaction, n = e.event, o = this.states;
        if (o && o.length) {
          for (var l = !1, c = 0; c < o.length; c++) {
            var p = o[c];
            e.state = p;
            var h = p.options, g = p.methods, d = g.beforeEnd && g.beforeEnd(e);
            if (d) return this.endResult = d, !1;
            l = l || !l && this.shouldDo(h, !0, e.phase, !0);
          }
          l && r.move({ event: n, preEnd: !0 });
        }
      } }, { key: "stop", value: function(e) {
        var r = e.interaction;
        if (this.states && this.states.length) {
          var n = W({ states: this.states, interactable: r.interactable, element: r.element, rect: null }, e);
          this.fillArg(n);
          for (var o = 0, l = this.states; o < l.length; o++) {
            var c = l[o];
            n.state = c, c.methods.stop && c.methods.stop(n);
          }
          this.states = null, this.endResult = null;
        }
      } }, { key: "prepareStates", value: function(e) {
        this.states = [];
        for (var r = 0; r < e.length; r++) {
          var n = e[r], o = n.options, l = n.methods, c = n.name;
          this.states.push({ options: o, methods: l, index: r, name: c });
        }
        return this.states;
      } }, { key: "restoreInteractionCoords", value: function(e) {
        var r = e.interaction, n = r.coords, o = r.rect, l = r.modification;
        if (l.result) {
          for (var c = l.startDelta, p = l.result, h = p.delta, g = p.rectDelta, d = 0, b = [[n.start, c], [n.cur, h]]; d < b.length; d++) {
            var x = b[d], I = x[0], E = x[1];
            I.page.x -= E.x, I.page.y -= E.y, I.client.x -= E.x, I.client.y -= E.y;
          }
          o.left -= g.left, o.right -= g.right, o.top -= g.top, o.bottom -= g.bottom;
        }
      } }, { key: "shouldDo", value: function(e, r, n, o) {
        return !(!e || e.enabled === !1 || o && !e.endOnly || e.endOnly && !r || n === "start" && !e.setStart);
      } }, { key: "copyFrom", value: function(e) {
        this.startOffset = e.startOffset, this.startDelta = e.startDelta, this.startEdges = e.startEdges, this.edges = e.edges, this.states = e.states.map(function(r) {
          return ke(r);
        }), this.result = ht(W({}, e.result.coords), W({}, e.result.rect));
      } }, { key: "destroy", value: function() {
        for (var e in this) this[e] = null;
      } }]), t;
    }();
    function ht(t, e) {
      return { rect: e, coords: t, delta: { x: 0, y: 0 }, rectDelta: { left: 0, right: 0, top: 0, bottom: 0 }, eventProps: [], changed: !0 };
    }
    function ye(t, e) {
      var r = t.defaults, n = { start: t.start, set: t.set, beforeEnd: t.beforeEnd, stop: t.stop }, o = function(l) {
        var c = l || {};
        for (var p in c.enabled = c.enabled !== !1, r) p in c || (c[p] = r[p]);
        var h = { options: c, methods: n, name: e, enable: function() {
          return c.enabled = !0, h;
        }, disable: function() {
          return c.enabled = !1, h;
        } };
        return h;
      };
      return e && typeof e == "string" && (o._defaults = r, o._methods = n), o;
    }
    function Ve(t) {
      var e = t.iEvent, r = t.interaction.modification.result;
      r && (e.modifiers = r.eventProps);
    }
    var _o = { id: "modifiers/base", before: ["actions"], install: function(t) {
      t.defaults.perAction.modifiers = [];
    }, listeners: { "interactions:new": function(t) {
      var e = t.interaction;
      e.modification = new ir(e);
    }, "interactions:before-action-start": function(t) {
      var e = t.interaction, r = t.interaction.modification;
      r.start(t, e.coords.start.page), e.edges = r.edges, r.applyToInteraction(t);
    }, "interactions:before-action-move": function(t) {
      var e = t.interaction, r = e.modification, n = r.setAndApply(t);
      return e.edges = r.edges, n;
    }, "interactions:before-action-end": function(t) {
      var e = t.interaction, r = e.modification, n = r.beforeEnd(t);
      return e.edges = r.startEdges, n;
    }, "interactions:action-start": Ve, "interactions:action-move": Ve, "interactions:action-end": Ve, "interactions:after-action-start": function(t) {
      return t.interaction.modification.restoreInteractionCoords(t);
    }, "interactions:after-action-move": function(t) {
      return t.interaction.modification.restoreInteractionCoords(t);
    }, "interactions:stop": function(t) {
      return t.interaction.modification.stop(t);
    } } }, bn = _o, yn = { base: { preventDefault: "auto", deltaSource: "page" }, perAction: { enabled: !1, origin: { x: 0, y: 0 } }, actions: {} }, or = function(t) {
      C(r, t);
      var e = P(r);
      function r(n, o, l, c, p, h, g) {
        var d;
        f(this, r), (d = e.call(this, n)).relatedTarget = null, d.screenX = void 0, d.screenY = void 0, d.button = void 0, d.buttons = void 0, d.ctrlKey = void 0, d.shiftKey = void 0, d.altKey = void 0, d.metaKey = void 0, d.page = void 0, d.client = void 0, d.delta = void 0, d.rect = void 0, d.x0 = void 0, d.y0 = void 0, d.t0 = void 0, d.dt = void 0, d.duration = void 0, d.clientX0 = void 0, d.clientY0 = void 0, d.velocity = void 0, d.speed = void 0, d.swipe = void 0, d.axes = void 0, d.preEnd = void 0, p = p || n.element;
        var b = n.interactable, x = (b && b.options || yn).deltaSource, I = Ne(b, p, l), E = c === "start", M = c === "end", $ = E ? T(d) : n.prevEvent, z = E ? n.coords.start : M ? { page: $.page, client: $.client, timeStamp: n.coords.cur.timeStamp } : n.coords.cur;
        return d.page = W({}, z.page), d.client = W({}, z.client), d.rect = W({}, n.rect), d.timeStamp = z.timeStamp, M || (d.page.x -= I.x, d.page.y -= I.y, d.client.x -= I.x, d.client.y -= I.y), d.ctrlKey = o.ctrlKey, d.altKey = o.altKey, d.shiftKey = o.shiftKey, d.metaKey = o.metaKey, d.button = o.button, d.buttons = o.buttons, d.target = p, d.currentTarget = p, d.preEnd = h, d.type = g || l + (c || ""), d.interactable = b, d.t0 = E ? n.pointers[n.pointers.length - 1].downTime : $.t0, d.x0 = n.coords.start.page.x - I.x, d.y0 = n.coords.start.page.y - I.y, d.clientX0 = n.coords.start.client.x - I.x, d.clientY0 = n.coords.start.client.y - I.y, d.delta = E || M ? { x: 0, y: 0 } : { x: d[x].x - $[x].x, y: d[x].y - $[x].y }, d.dt = n.coords.delta.timeStamp, d.duration = d.timeStamp - d.t0, d.velocity = W({}, n.coords.velocity[x]), d.speed = Ge(d.velocity.x, d.velocity.y), d.swipe = M || c === "inertiastart" ? d.getSwipe() : null, d;
      }
      return y(r, [{ key: "getSwipe", value: function() {
        var n = this._interaction;
        if (n.prevEvent.speed < 600 || this.timeStamp - n.prevEvent.timeStamp > 150) return null;
        var o = 180 * Math.atan2(n.prevEvent.velocityY, n.prevEvent.velocityX) / Math.PI;
        o < 0 && (o += 360);
        var l = 112.5 <= o && o < 247.5, c = 202.5 <= o && o < 337.5;
        return { up: c, down: !c && 22.5 <= o && o < 157.5, left: l, right: !l && (292.5 <= o || o < 67.5), angle: o, speed: n.prevEvent.speed, velocity: { x: n.prevEvent.velocityX, y: n.prevEvent.velocityY } };
      } }, { key: "preventDefault", value: function() {
      } }, { key: "stopImmediatePropagation", value: function() {
        this.immediatePropagationStopped = this.propagationStopped = !0;
      } }, { key: "stopPropagation", value: function() {
        this.propagationStopped = !0;
      } }]), r;
    }(ct);
    Object.defineProperties(or.prototype, { pageX: { get: function() {
      return this.page.x;
    }, set: function(t) {
      this.page.x = t;
    } }, pageY: { get: function() {
      return this.page.y;
    }, set: function(t) {
      this.page.y = t;
    } }, clientX: { get: function() {
      return this.client.x;
    }, set: function(t) {
      this.client.x = t;
    } }, clientY: { get: function() {
      return this.client.y;
    }, set: function(t) {
      this.client.y = t;
    } }, dx: { get: function() {
      return this.delta.x;
    }, set: function(t) {
      this.delta.x = t;
    } }, dy: { get: function() {
      return this.delta.y;
    }, set: function(t) {
      this.delta.y = t;
    } }, velocityX: { get: function() {
      return this.velocity.x;
    }, set: function(t) {
      this.velocity.x = t;
    } }, velocityY: { get: function() {
      return this.velocity.y;
    }, set: function(t) {
      this.velocity.y = t;
    } } });
    var Po = y(function t(e, r, n, o, l) {
      f(this, t), this.id = void 0, this.pointer = void 0, this.event = void 0, this.downTime = void 0, this.downTarget = void 0, this.id = e, this.pointer = r, this.event = n, this.downTime = o, this.downTarget = l;
    }), Io = function(t) {
      return t.interactable = "", t.element = "", t.prepared = "", t.pointerIsDown = "", t.pointerWasMoved = "", t._proxy = "", t;
    }({}), Tn = function(t) {
      return t.start = "", t.move = "", t.end = "", t.stop = "", t.interacting = "", t;
    }({}), Mo = 0, Ro = function() {
      function t(e) {
        var r = this, n = e.pointerType, o = e.scopeFire;
        f(this, t), this.interactable = null, this.element = null, this.rect = null, this._rects = void 0, this.edges = null, this._scopeFire = void 0, this.prepared = { name: null, axis: null, edges: null }, this.pointerType = void 0, this.pointers = [], this.downEvent = null, this.downPointer = {}, this._latestPointer = { pointer: null, event: null, eventTarget: null }, this.prevEvent = null, this.pointerIsDown = !1, this.pointerWasMoved = !1, this._interacting = !1, this._ending = !1, this._stopped = !0, this._proxy = void 0, this.simulation = null, this.doMove = Be(function(d) {
          this.move(d);
        }, "The interaction.doMove() method has been renamed to interaction.move()"), this.coords = { start: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, prev: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, cur: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, delta: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 }, velocity: { page: { x: 0, y: 0 }, client: { x: 0, y: 0 }, timeStamp: 0 } }, this._id = Mo++, this._scopeFire = o, this.pointerType = n;
        var l = this;
        this._proxy = {};
        var c = function(d) {
          Object.defineProperty(r._proxy, d, { get: function() {
            return l[d];
          } });
        };
        for (var p in Io) c(p);
        var h = function(d) {
          Object.defineProperty(r._proxy, d, { value: function() {
            return l[d].apply(l, arguments);
          } });
        };
        for (var g in Tn) h(g);
        this._scopeFire("interactions:new", { interaction: this });
      }
      return y(t, [{ key: "pointerMoveTolerance", get: function() {
        return 1;
      } }, { key: "pointerDown", value: function(e, r, n) {
        var o = this.updatePointer(e, r, n, !0), l = this.pointers[o];
        this._scopeFire("interactions:down", { pointer: e, event: r, eventTarget: n, pointerIndex: o, pointerInfo: l, type: "down", interaction: this });
      } }, { key: "start", value: function(e, r, n) {
        return !(this.interacting() || !this.pointerIsDown || this.pointers.length < (e.name === "gesture" ? 2 : 1) || !r.options[e.name].enabled) && (er(this.prepared, e), this.interactable = r, this.element = n, this.rect = r.getRect(n), this.edges = this.prepared.edges ? W({}, this.prepared.edges) : { left: !0, right: !0, top: !0, bottom: !0 }, this._stopped = !1, this._interacting = this._doPhase({ interaction: this, event: this.downEvent, phase: "start" }) && !this._stopped, this._interacting);
      } }, { key: "pointerMove", value: function(e, r, n) {
        this.simulation || this.modification && this.modification.endResult || this.updatePointer(e, r, n, !1);
        var o, l, c = this.coords.cur.page.x === this.coords.prev.page.x && this.coords.cur.page.y === this.coords.prev.page.y && this.coords.cur.client.x === this.coords.prev.client.x && this.coords.cur.client.y === this.coords.prev.client.y;
        this.pointerIsDown && !this.pointerWasMoved && (o = this.coords.cur.client.x - this.coords.start.client.x, l = this.coords.cur.client.y - this.coords.start.client.y, this.pointerWasMoved = Ge(o, l) > this.pointerMoveTolerance);
        var p, h, g, d = this.getPointerIndex(e), b = { pointer: e, pointerIndex: d, pointerInfo: this.pointers[d], event: r, type: "move", eventTarget: n, dx: o, dy: l, duplicate: c, interaction: this };
        c || (p = this.coords.velocity, h = this.coords.delta, g = Math.max(h.timeStamp / 1e3, 1e-3), p.page.x = h.page.x / g, p.page.y = h.page.y / g, p.client.x = h.client.x / g, p.client.y = h.client.y / g, p.timeStamp = g), this._scopeFire("interactions:move", b), c || this.simulation || (this.interacting() && (b.type = null, this.move(b)), this.pointerWasMoved && at(this.coords.prev, this.coords.cur));
      } }, { key: "move", value: function(e) {
        e && e.event || Vr(this.coords.delta), (e = W({ pointer: this._latestPointer.pointer, event: this._latestPointer.event, eventTarget: this._latestPointer.eventTarget, interaction: this }, e || {})).phase = "move", this._doPhase(e);
      } }, { key: "pointerUp", value: function(e, r, n, o) {
        var l = this.getPointerIndex(e);
        l === -1 && (l = this.updatePointer(e, r, n, !1));
        var c = /cancel$/i.test(r.type) ? "cancel" : "up";
        this._scopeFire("interactions:".concat(c), { pointer: e, pointerIndex: l, pointerInfo: this.pointers[l], event: r, eventTarget: n, type: c, curEventTarget: o, interaction: this }), this.simulation || this.end(r), this.removePointer(e, r);
      } }, { key: "documentBlur", value: function(e) {
        this.end(e), this._scopeFire("interactions:blur", { event: e, type: "blur", interaction: this });
      } }, { key: "end", value: function(e) {
        var r;
        this._ending = !0, e = e || this._latestPointer.event, this.interacting() && (r = this._doPhase({ event: e, interaction: this, phase: "end" })), this._ending = !1, r === !0 && this.stop();
      } }, { key: "currentAction", value: function() {
        return this._interacting ? this.prepared.name : null;
      } }, { key: "interacting", value: function() {
        return this._interacting;
      } }, { key: "stop", value: function() {
        this._scopeFire("interactions:stop", { interaction: this }), this.interactable = this.element = null, this._interacting = !1, this._stopped = !0, this.prepared.name = this.prevEvent = null;
      } }, { key: "getPointerIndex", value: function(e) {
        var r = Ye(e);
        return this.pointerType === "mouse" || this.pointerType === "pen" ? this.pointers.length - 1 : Ke(this.pointers, function(n) {
          return n.id === r;
        });
      } }, { key: "getPointerInfo", value: function(e) {
        return this.pointers[this.getPointerIndex(e)];
      } }, { key: "updatePointer", value: function(e, r, n, o) {
        var l, c, p, h = Ye(e), g = this.getPointerIndex(e), d = this.pointers[g];
        return o = o !== !1 && (o || /(down|start)$/i.test(r.type)), d ? d.pointer = e : (d = new Po(h, e, r, null, null), g = this.pointers.length, this.pointers.push(d)), ao(this.coords.cur, this.pointers.map(function(b) {
          return b.pointer;
        }), this._now()), l = this.coords.delta, c = this.coords.prev, p = this.coords.cur, l.page.x = p.page.x - c.page.x, l.page.y = p.page.y - c.page.y, l.client.x = p.client.x - c.client.x, l.client.y = p.client.y - c.client.y, l.timeStamp = p.timeStamp - c.timeStamp, o && (this.pointerIsDown = !0, d.downTime = this.coords.cur.timeStamp, d.downTarget = n, st(this.downPointer, e), this.interacting() || (at(this.coords.start, this.coords.cur), at(this.coords.prev, this.coords.cur), this.downEvent = r, this.pointerWasMoved = !1)), this._updateLatestPointer(e, r, n), this._scopeFire("interactions:update-pointer", { pointer: e, event: r, eventTarget: n, down: o, pointerInfo: d, pointerIndex: g, interaction: this }), g;
      } }, { key: "removePointer", value: function(e, r) {
        var n = this.getPointerIndex(e);
        if (n !== -1) {
          var o = this.pointers[n];
          this._scopeFire("interactions:remove-pointer", { pointer: e, event: r, eventTarget: null, pointerIndex: n, pointerInfo: o, interaction: this }), this.pointers.splice(n, 1), this.pointerIsDown = !1;
        }
      } }, { key: "_updateLatestPointer", value: function(e, r, n) {
        this._latestPointer.pointer = e, this._latestPointer.event = r, this._latestPointer.eventTarget = n;
      } }, { key: "destroy", value: function() {
        this._latestPointer.pointer = null, this._latestPointer.event = null, this._latestPointer.eventTarget = null;
      } }, { key: "_createPreparedEvent", value: function(e, r, n, o) {
        return new or(this, e, this.prepared.name, r, this.element, n, o);
      } }, { key: "_fireEvent", value: function(e) {
        var r;
        (r = this.interactable) == null || r.fire(e), (!this.prevEvent || e.timeStamp >= this.prevEvent.timeStamp) && (this.prevEvent = e);
      } }, { key: "_doPhase", value: function(e) {
        var r = e.event, n = e.phase, o = e.preEnd, l = e.type, c = this.rect;
        if (c && n === "move" && (ot(this.edges, c, this.coords.delta[this.interactable.options.deltaSource]), c.width = c.right - c.left, c.height = c.bottom - c.top), this._scopeFire("interactions:before-action-".concat(n), e) === !1) return !1;
        var p = e.iEvent = this._createPreparedEvent(r, n, o, l);
        return this._scopeFire("interactions:action-".concat(n), e), n === "start" && (this.prevEvent = p), this._fireEvent(p), this._scopeFire("interactions:after-action-".concat(n), e), !0;
      } }, { key: "_now", value: function() {
        return Date.now();
      } }]), t;
    }();
    function wn(t) {
      xn(t.interaction);
    }
    function xn(t) {
      if (!function(r) {
        return !(!r.offset.pending.x && !r.offset.pending.y);
      }(t)) return !1;
      var e = t.offset.pending;
      return sr(t.coords.cur, e), sr(t.coords.delta, e), ot(t.edges, t.rect, e), e.x = 0, e.y = 0, !0;
    }
    function Do(t) {
      var e = t.x, r = t.y;
      this.offset.pending.x += e, this.offset.pending.y += r, this.offset.total.x += e, this.offset.total.y += r;
    }
    function sr(t, e) {
      var r = t.page, n = t.client, o = e.x, l = e.y;
      r.x += o, r.y += l, n.x += o, n.y += l;
    }
    Tn.offsetBy = "";
    var ko = { id: "offset", before: ["modifiers", "pointer-events", "actions", "inertia"], install: function(t) {
      t.Interaction.prototype.offsetBy = Do;
    }, listeners: { "interactions:new": function(t) {
      t.interaction.offset = { total: { x: 0, y: 0 }, pending: { x: 0, y: 0 } };
    }, "interactions:update-pointer": function(t) {
      return function(e) {
        e.pointerIsDown && (sr(e.coords.cur, e.offset.total), e.offset.pending.x = 0, e.offset.pending.y = 0);
      }(t.interaction);
    }, "interactions:before-action-start": wn, "interactions:before-action-move": wn, "interactions:before-action-end": function(t) {
      var e = t.interaction;
      if (xn(e)) return e.move({ offset: !0 }), e.end(), !1;
    }, "interactions:stop": function(t) {
      var e = t.interaction;
      e.offset.total.x = 0, e.offset.total.y = 0, e.offset.pending.x = 0, e.offset.pending.y = 0;
    } } }, Sn = ko, zo = function() {
      function t(e) {
        f(this, t), this.active = !1, this.isModified = !1, this.smoothEnd = !1, this.allowResume = !1, this.modification = void 0, this.modifierCount = 0, this.modifierArg = void 0, this.startCoords = void 0, this.t0 = 0, this.v0 = 0, this.te = 0, this.targetOffset = void 0, this.modifiedOffset = void 0, this.currentOffset = void 0, this.lambda_v0 = 0, this.one_ve_v0 = 0, this.timeout = void 0, this.interaction = void 0, this.interaction = e;
      }
      return y(t, [{ key: "start", value: function(e) {
        var r = this.interaction, n = dt(r);
        if (!n || !n.enabled) return !1;
        var o = r.coords.velocity.client, l = Ge(o.x, o.y), c = this.modification || (this.modification = new ir(r));
        if (c.copyFrom(r.modification), this.t0 = r._now(), this.allowResume = n.allowResume, this.v0 = l, this.currentOffset = { x: 0, y: 0 }, this.startCoords = r.coords.cur.page, this.modifierArg = c.fillArg({ pageCoords: this.startCoords, preEnd: !0, phase: "inertiastart" }), this.t0 - r.coords.cur.timeStamp < 50 && l > n.minSpeed && l > n.endSpeed) this.startInertia();
        else {
          if (c.result = c.setAll(this.modifierArg), !c.result.changed) return !1;
          this.startSmoothEnd();
        }
        return r.modification.result.rect = null, r.offsetBy(this.targetOffset), r._doPhase({ interaction: r, event: e, phase: "inertiastart" }), r.offsetBy({ x: -this.targetOffset.x, y: -this.targetOffset.y }), r.modification.result.rect = null, this.active = !0, r.simulation = this, !0;
      } }, { key: "startInertia", value: function() {
        var e = this, r = this.interaction.coords.velocity.client, n = dt(this.interaction), o = n.resistance, l = -Math.log(n.endSpeed / this.v0) / o;
        this.targetOffset = { x: (r.x - l) / o, y: (r.y - l) / o }, this.te = l, this.lambda_v0 = o / this.v0, this.one_ve_v0 = 1 - n.endSpeed / this.v0;
        var c = this.modification, p = this.modifierArg;
        p.pageCoords = { x: this.startCoords.x + this.targetOffset.x, y: this.startCoords.y + this.targetOffset.y }, c.result = c.setAll(p), c.result.changed && (this.isModified = !0, this.modifiedOffset = { x: this.targetOffset.x + c.result.delta.x, y: this.targetOffset.y + c.result.delta.y }), this.onNextFrame(function() {
          return e.inertiaTick();
        });
      } }, { key: "startSmoothEnd", value: function() {
        var e = this;
        this.smoothEnd = !0, this.isModified = !0, this.targetOffset = { x: this.modification.result.delta.x, y: this.modification.result.delta.y }, this.onNextFrame(function() {
          return e.smoothEndTick();
        });
      } }, { key: "onNextFrame", value: function(e) {
        var r = this;
        this.timeout = be.request(function() {
          r.active && e();
        });
      } }, { key: "inertiaTick", value: function() {
        var e, r, n, o, l, c, p, h = this, g = this.interaction, d = dt(g).resistance, b = (g._now() - this.t0) / 1e3;
        if (b < this.te) {
          var x, I = 1 - (Math.exp(-d * b) - this.lambda_v0) / this.one_ve_v0;
          this.isModified ? (e = 0, r = 0, n = this.targetOffset.x, o = this.targetOffset.y, l = this.modifiedOffset.x, c = this.modifiedOffset.y, x = { x: On(p = I, e, n, l), y: On(p, r, o, c) }) : x = { x: this.targetOffset.x * I, y: this.targetOffset.y * I };
          var E = { x: x.x - this.currentOffset.x, y: x.y - this.currentOffset.y };
          this.currentOffset.x += E.x, this.currentOffset.y += E.y, g.offsetBy(E), g.move(), this.onNextFrame(function() {
            return h.inertiaTick();
          });
        } else g.offsetBy({ x: this.modifiedOffset.x - this.currentOffset.x, y: this.modifiedOffset.y - this.currentOffset.y }), this.end();
      } }, { key: "smoothEndTick", value: function() {
        var e = this, r = this.interaction, n = r._now() - this.t0, o = dt(r).smoothEndDuration;
        if (n < o) {
          var l = { x: Cn(n, 0, this.targetOffset.x, o), y: Cn(n, 0, this.targetOffset.y, o) }, c = { x: l.x - this.currentOffset.x, y: l.y - this.currentOffset.y };
          this.currentOffset.x += c.x, this.currentOffset.y += c.y, r.offsetBy(c), r.move({ skipModifiers: this.modifierCount }), this.onNextFrame(function() {
            return e.smoothEndTick();
          });
        } else r.offsetBy({ x: this.targetOffset.x - this.currentOffset.x, y: this.targetOffset.y - this.currentOffset.y }), this.end();
      } }, { key: "resume", value: function(e) {
        var r = e.pointer, n = e.event, o = e.eventTarget, l = this.interaction;
        l.offsetBy({ x: -this.currentOffset.x, y: -this.currentOffset.y }), l.updatePointer(r, n, o, !0), l._doPhase({ interaction: l, event: n, phase: "resume" }), at(l.coords.prev, l.coords.cur), this.stop();
      } }, { key: "end", value: function() {
        this.interaction.move(), this.interaction.end(), this.stop();
      } }, { key: "stop", value: function() {
        this.active = this.smoothEnd = !1, this.interaction.simulation = null, be.cancel(this.timeout);
      } }]), t;
    }();
    function dt(t) {
      var e = t.interactable, r = t.prepared;
      return e && e.options && r.name && e.options[r.name].inertia;
    }
    var $o = { id: "inertia", before: ["modifiers", "actions"], install: function(t) {
      var e = t.defaults;
      t.usePlugin(Sn), t.usePlugin(bn), t.actions.phases.inertiastart = !0, t.actions.phases.resume = !0, e.perAction.inertia = { enabled: !1, resistance: 10, minSpeed: 100, endSpeed: 10, allowResume: !0, smoothEndDuration: 300 };
    }, listeners: { "interactions:new": function(t) {
      var e = t.interaction;
      e.inertia = new zo(e);
    }, "interactions:before-action-end": function(t) {
      var e = t.interaction, r = t.event;
      return (!e._interacting || e.simulation || !e.inertia.start(r)) && null;
    }, "interactions:down": function(t) {
      var e = t.interaction, r = t.eventTarget, n = e.inertia;
      if (n.active) for (var o = r; w.element(o); ) {
        if (o === e.element) {
          n.resume(t);
          break;
        }
        o = pe(o);
      }
    }, "interactions:stop": function(t) {
      var e = t.interaction.inertia;
      e.active && e.stop();
    }, "interactions:before-action-resume": function(t) {
      var e = t.interaction.modification;
      e.stop(t), e.start(t, t.interaction.coords.cur.page), e.applyToInteraction(t);
    }, "interactions:before-action-inertiastart": function(t) {
      return t.interaction.modification.setAndApply(t);
    }, "interactions:action-resume": Ve, "interactions:action-inertiastart": Ve, "interactions:after-action-inertiastart": function(t) {
      return t.interaction.modification.restoreInteractionCoords(t);
    }, "interactions:after-action-resume": function(t) {
      return t.interaction.modification.restoreInteractionCoords(t);
    } } };
    function On(t, e, r, n) {
      var o = 1 - t;
      return o * o * e + 2 * o * t * r + t * t * n;
    }
    function Cn(t, e, r, n) {
      return -r * (t /= n) * (t - 2) + e;
    }
    var jo = $o;
    function En(t, e) {
      for (var r = 0; r < e.length; r++) {
        var n = e[r];
        if (t.immediatePropagationStopped) break;
        n(t);
      }
    }
    var _n = function() {
      function t(e) {
        f(this, t), this.options = void 0, this.types = {}, this.propagationStopped = !1, this.immediatePropagationStopped = !1, this.global = void 0, this.options = W({}, e || {});
      }
      return y(t, [{ key: "fire", value: function(e) {
        var r, n = this.global;
        (r = this.types[e.type]) && En(e, r), !e.propagationStopped && n && (r = n[e.type]) && En(e, r);
      } }, { key: "on", value: function(e, r) {
        var n = Oe(e, r);
        for (e in n) this.types[e] = tn(this.types[e] || [], n[e]);
      } }, { key: "off", value: function(e, r) {
        var n = Oe(e, r);
        for (e in n) {
          var o = this.types[e];
          if (o && o.length) for (var l = 0, c = n[e]; l < c.length; l++) {
            var p = c[l], h = o.indexOf(p);
            h !== -1 && o.splice(h, 1);
          }
        }
      } }, { key: "getRect", value: function(e) {
        return null;
      } }]), t;
    }(), Ao = function() {
      function t(e) {
        f(this, t), this.currentTarget = void 0, this.originalEvent = void 0, this.type = void 0, this.originalEvent = e, st(this, e);
      }
      return y(t, [{ key: "preventOriginalDefault", value: function() {
        this.originalEvent.preventDefault();
      } }, { key: "stopPropagation", value: function() {
        this.originalEvent.stopPropagation();
      } }, { key: "stopImmediatePropagation", value: function() {
        this.originalEvent.stopImmediatePropagation();
      } }]), t;
    }();
    function qe(t) {
      return w.object(t) ? { capture: !!t.capture, passive: !!t.passive } : { capture: !!t, passive: !1 };
    }
    function ft(t, e) {
      return t === e || (typeof t == "boolean" ? !!e.capture === t && !e.passive : !!t.capture == !!e.capture && !!t.passive == !!e.passive);
    }
    var Lo = { id: "events", install: function(t) {
      var e, r = [], n = {}, o = [], l = { add: c, remove: p, addDelegate: function(d, b, x, I, E) {
        var M = qe(E);
        if (!n[x]) {
          n[x] = [];
          for (var $ = 0; $ < o.length; $++) {
            var z = o[$];
            c(z, x, h), c(z, x, g, !0);
          }
        }
        var A = n[x], N = Xe(A, function(K) {
          return K.selector === d && K.context === b;
        });
        N || (N = { selector: d, context: b, listeners: [] }, A.push(N)), N.listeners.push({ func: I, options: M });
      }, removeDelegate: function(d, b, x, I, E) {
        var M, $ = qe(E), z = n[x], A = !1;
        if (z)
          for (M = z.length - 1; M >= 0; M--) {
            var N = z[M];
            if (N.selector === d && N.context === b) {
              for (var K = N.listeners, F = K.length - 1; F >= 0; F--) {
                var G = K[F];
                if (G.func === I && ft(G.options, $)) {
                  K.splice(F, 1), K.length || (z.splice(M, 1), p(b, x, h), p(b, x, g, !0)), A = !0;
                  break;
                }
              }
              if (A) break;
            }
          }
      }, delegateListener: h, delegateUseCapture: g, delegatedEvents: n, documents: o, targets: r, supportsOptions: !1, supportsPassive: !1 };
      function c(d, b, x, I) {
        if (d.addEventListener) {
          var E = qe(I), M = Xe(r, function($) {
            return $.eventTarget === d;
          });
          M || (M = { eventTarget: d, events: {} }, r.push(M)), M.events[b] || (M.events[b] = []), Xe(M.events[b], function($) {
            return $.func === x && ft($.options, E);
          }) || (d.addEventListener(b, x, l.supportsOptions ? E : E.capture), M.events[b].push({ func: x, options: E }));
        }
      }
      function p(d, b, x, I) {
        if (d.addEventListener && d.removeEventListener) {
          var E = Ke(r, function(te) {
            return te.eventTarget === d;
          }), M = r[E];
          if (M && M.events) if (b !== "all") {
            var $ = !1, z = M.events[b];
            if (z) {
              if (x === "all") {
                for (var A = z.length - 1; A >= 0; A--) {
                  var N = z[A];
                  p(d, b, N.func, N.options);
                }
                return;
              }
              for (var K = qe(I), F = 0; F < z.length; F++) {
                var G = z[F];
                if (G.func === x && ft(G.options, K)) {
                  d.removeEventListener(b, x, l.supportsOptions ? K : K.capture), z.splice(F, 1), z.length === 0 && (delete M.events[b], $ = !0);
                  break;
                }
              }
            }
            $ && !Object.keys(M.events).length && r.splice(E, 1);
          } else for (b in M.events) M.events.hasOwnProperty(b) && p(d, b, "all");
        }
      }
      function h(d, b) {
        for (var x = qe(b), I = new Ao(d), E = n[d.type], M = en(d)[0], $ = M; w.element($); ) {
          for (var z = 0; z < E.length; z++) {
            var A = E[z], N = A.selector, K = A.context;
            if (me($, N) && Se(K, M) && Se(K, $)) {
              var F = A.listeners;
              I.currentTarget = $;
              for (var G = 0; G < F.length; G++) {
                var te = F[G];
                ft(te.options, x) && te.func(I);
              }
            }
          }
          $ = pe($);
        }
      }
      function g(d) {
        return h(d, !0);
      }
      return (e = t.document) == null || e.createElement("div").addEventListener("test", null, { get capture() {
        return l.supportsOptions = !0;
      }, get passive() {
        return l.supportsPassive = !0;
      } }), t.events = l, l;
    } }, ar = { methodOrder: ["simulationResume", "mouseOrPen", "hasPointer", "idle"], search: function(t) {
      for (var e = 0, r = ar.methodOrder; e < r.length; e++) {
        var n = r[e], o = ar[n](t);
        if (o) return o;
      }
      return null;
    }, simulationResume: function(t) {
      var e = t.pointerType, r = t.eventType, n = t.eventTarget, o = t.scope;
      if (!/down|start/i.test(r)) return null;
      for (var l = 0, c = o.interactions.list; l < c.length; l++) {
        var p = c[l], h = n;
        if (p.simulation && p.simulation.allowResume && p.pointerType === e) for (; h; ) {
          if (h === p.element) return p;
          h = pe(h);
        }
      }
      return null;
    }, mouseOrPen: function(t) {
      var e, r = t.pointerId, n = t.pointerType, o = t.eventType, l = t.scope;
      if (n !== "mouse" && n !== "pen") return null;
      for (var c = 0, p = l.interactions.list; c < p.length; c++) {
        var h = p[c];
        if (h.pointerType === n) {
          if (h.simulation && !Pn(h, r)) continue;
          if (h.interacting()) return h;
          e || (e = h);
        }
      }
      if (e) return e;
      for (var g = 0, d = l.interactions.list; g < d.length; g++) {
        var b = d[g];
        if (!(b.pointerType !== n || /down/i.test(o) && b.simulation)) return b;
      }
      return null;
    }, hasPointer: function(t) {
      for (var e = t.pointerId, r = 0, n = t.scope.interactions.list; r < n.length; r++) {
        var o = n[r];
        if (Pn(o, e)) return o;
      }
      return null;
    }, idle: function(t) {
      for (var e = t.pointerType, r = 0, n = t.scope.interactions.list; r < n.length; r++) {
        var o = n[r];
        if (o.pointers.length === 1) {
          var l = o.interactable;
          if (l && (!l.options.gesture || !l.options.gesture.enabled)) continue;
        } else if (o.pointers.length >= 2) continue;
        if (!o.interacting() && e === o.pointerType) return o;
      }
      return null;
    } };
    function Pn(t, e) {
      return t.pointers.some(function(r) {
        return r.id === e;
      });
    }
    var Ho = ar, lr = ["pointerDown", "pointerMove", "pointerUp", "updatePointer", "removePointer", "windowBlur"];
    function In(t, e) {
      return function(r) {
        var n = e.interactions.list, o = Qr(r), l = en(r), c = l[0], p = l[1], h = [];
        if (/^touch/.test(r.type)) {
          e.prevTouchTime = e.now();
          for (var g = 0, d = r.changedTouches; g < d.length; g++) {
            var b = d[g], x = { pointer: b, pointerId: Ye(b), pointerType: o, eventType: r.type, eventTarget: c, curEventTarget: p, scope: e }, I = Mn(x);
            h.push([x.pointer, x.eventTarget, x.curEventTarget, I]);
          }
        } else {
          var E = !1;
          if (!oe.supportsPointerEvent && /mouse/.test(r.type)) {
            for (var M = 0; M < n.length && !E; M++) E = n[M].pointerType !== "mouse" && n[M].pointerIsDown;
            E = E || e.now() - e.prevTouchTime < 500 || r.timeStamp === 0;
          }
          if (!E) {
            var $ = { pointer: r, pointerId: Ye(r), pointerType: o, eventType: r.type, curEventTarget: p, eventTarget: c, scope: e }, z = Mn($);
            h.push([$.pointer, $.eventTarget, $.curEventTarget, z]);
          }
        }
        for (var A = 0; A < h.length; A++) {
          var N = h[A], K = N[0], F = N[1], G = N[2];
          N[3][t](K, r, F, G);
        }
      };
    }
    function Mn(t) {
      var e = t.pointerType, r = t.scope, n = { interaction: Ho.search(t), searchDetails: t };
      return r.fire("interactions:find", n), n.interaction || r.interactions.new({ pointerType: e });
    }
    function cr(t, e) {
      var r = t.doc, n = t.scope, o = t.options, l = n.interactions.docEvents, c = n.events, p = c[e];
      for (var h in n.browser.isIOS && !o.events && (o.events = { passive: !1 }), c.delegatedEvents) p(r, h, c.delegateListener), p(r, h, c.delegateUseCapture, !0);
      for (var g = o && o.events, d = 0; d < l.length; d++) {
        var b = l[d];
        p(r, b.type, b.listener, g);
      }
    }
    var Wo = { id: "core/interactions", install: function(t) {
      for (var e = {}, r = 0; r < lr.length; r++) {
        var n = lr[r];
        e[n] = In(n, t);
      }
      var o, l = oe.pEventTypes;
      function c() {
        for (var p = 0, h = t.interactions.list; p < h.length; p++) {
          var g = h[p];
          if (g.pointerIsDown && g.pointerType === "touch" && !g._interacting) for (var d = function() {
            var I = x[b];
            t.documents.some(function(E) {
              return Se(E.doc, I.downTarget);
            }) || g.removePointer(I.pointer, I.event);
          }, b = 0, x = g.pointers; b < x.length; b++) d();
        }
      }
      (o = Q.PointerEvent ? [{ type: l.down, listener: c }, { type: l.down, listener: e.pointerDown }, { type: l.move, listener: e.pointerMove }, { type: l.up, listener: e.pointerUp }, { type: l.cancel, listener: e.pointerUp }] : [{ type: "mousedown", listener: e.pointerDown }, { type: "mousemove", listener: e.pointerMove }, { type: "mouseup", listener: e.pointerUp }, { type: "touchstart", listener: c }, { type: "touchstart", listener: e.pointerDown }, { type: "touchmove", listener: e.pointerMove }, { type: "touchend", listener: e.pointerUp }, { type: "touchcancel", listener: e.pointerUp }]).push({ type: "blur", listener: function(p) {
        for (var h = 0, g = t.interactions.list; h < g.length; h++)
          g[h].documentBlur(p);
      } }), t.prevTouchTime = 0, t.Interaction = function(p) {
        C(g, p);
        var h = P(g);
        function g() {
          return f(this, g), h.apply(this, arguments);
        }
        return y(g, [{ key: "pointerMoveTolerance", get: function() {
          return t.interactions.pointerMoveTolerance;
        }, set: function(d) {
          t.interactions.pointerMoveTolerance = d;
        } }, { key: "_now", value: function() {
          return t.now();
        } }]), g;
      }(Ro), t.interactions = { list: [], new: function(p) {
        p.scopeFire = function(g, d) {
          return t.fire(g, d);
        };
        var h = new t.Interaction(p);
        return t.interactions.list.push(h), h;
      }, listeners: e, docEvents: o, pointerMoveTolerance: 1 }, t.usePlugin(mn);
    }, listeners: { "scope:add-document": function(t) {
      return cr(t, "add");
    }, "scope:remove-document": function(t) {
      return cr(t, "remove");
    }, "interactable:unset": function(t, e) {
      for (var r = t.interactable, n = e.interactions.list.length - 1; n >= 0; n--) {
        var o = e.interactions.list[n];
        o.interactable === r && (o.stop(), e.fire("interactions:destroy", { interaction: o }), o.destroy(), e.interactions.list.length > 2 && e.interactions.list.splice(n, 1));
      }
    } }, onDocSignal: cr, doOnInteractions: In, methodNames: lr }, Fo = Wo, Te = function(t) {
      return t[t.On = 0] = "On", t[t.Off = 1] = "Off", t;
    }(Te || {}), Uo = function() {
      function t(e, r, n, o) {
        f(this, t), this.target = void 0, this.options = void 0, this._actions = void 0, this.events = new _n(), this._context = void 0, this._win = void 0, this._doc = void 0, this._scopeEvents = void 0, this._actions = r.actions, this.target = e, this._context = r.context || n, this._win = B(Kr(e) ? this._context : e), this._doc = this._win.document, this._scopeEvents = o, this.set(r);
      }
      return y(t, [{ key: "_defaults", get: function() {
        return { base: {}, perAction: {}, actions: {} };
      } }, { key: "setOnEvents", value: function(e, r) {
        return w.func(r.onstart) && this.on("".concat(e, "start"), r.onstart), w.func(r.onmove) && this.on("".concat(e, "move"), r.onmove), w.func(r.onend) && this.on("".concat(e, "end"), r.onend), w.func(r.oninertiastart) && this.on("".concat(e, "inertiastart"), r.oninertiastart), this;
      } }, { key: "updatePerActionListeners", value: function(e, r, n) {
        var o, l = this, c = (o = this._actions.map[e]) == null ? void 0 : o.filterEventType, p = function(h) {
          return (c == null || c(h)) && pt(h, l._actions);
        };
        (w.array(r) || w.object(r)) && this._onOff(Te.Off, e, r, void 0, p), (w.array(n) || w.object(n)) && this._onOff(Te.On, e, n, void 0, p);
      } }, { key: "setPerAction", value: function(e, r) {
        var n = this._defaults;
        for (var o in r) {
          var l = o, c = this.options[e], p = r[l];
          l === "listeners" && this.updatePerActionListeners(e, c.listeners, p), w.array(p) ? c[l] = rn(p) : w.plainObject(p) ? (c[l] = W(c[l] || {}, ke(p)), w.object(n.perAction[l]) && "enabled" in n.perAction[l] && (c[l].enabled = p.enabled !== !1)) : w.bool(p) && w.object(n.perAction[l]) ? c[l].enabled = p : c[l] = p;
        }
      } }, { key: "getRect", value: function(e) {
        return e = e || (w.element(this.target) ? this.target : null), w.string(this.target) && (e = e || this._context.querySelector(this.target)), Nt(e);
      } }, { key: "rectChecker", value: function(e) {
        var r = this;
        return w.func(e) ? (this.getRect = function(n) {
          var o = W({}, e.apply(r, n));
          return "width" in o || (o.width = o.right - o.left, o.height = o.bottom - o.top), o;
        }, this) : e === null ? (delete this.getRect, this) : this.getRect;
      } }, { key: "_backCompatOption", value: function(e, r) {
        if (Kr(r) || w.object(r)) {
          for (var n in this.options[e] = r, this._actions.map) this.options[n][e] = r;
          return this;
        }
        return this.options[e];
      } }, { key: "origin", value: function(e) {
        return this._backCompatOption("origin", e);
      } }, { key: "deltaSource", value: function(e) {
        return e === "page" || e === "client" ? (this.options.deltaSource = e, this) : this.options.deltaSource;
      } }, { key: "getAllElements", value: function() {
        var e = this.target;
        return w.string(e) ? Array.from(this._context.querySelectorAll(e)) : w.func(e) && e.getAllElements ? e.getAllElements() : w.element(e) ? [e] : [];
      } }, { key: "context", value: function() {
        return this._context;
      } }, { key: "inContext", value: function(e) {
        return this._context === e.ownerDocument || Se(this._context, e);
      } }, { key: "testIgnoreAllow", value: function(e, r, n) {
        return !this.testIgnore(e.ignoreFrom, r, n) && this.testAllow(e.allowFrom, r, n);
      } }, { key: "testAllow", value: function(e, r, n) {
        return !e || !!w.element(n) && (w.string(e) ? Ft(n, e, r) : !!w.element(e) && Se(e, n));
      } }, { key: "testIgnore", value: function(e, r, n) {
        return !(!e || !w.element(n)) && (w.string(e) ? Ft(n, e, r) : !!w.element(e) && Se(e, n));
      } }, { key: "fire", value: function(e) {
        return this.events.fire(e), this;
      } }, { key: "_onOff", value: function(e, r, n, o, l) {
        w.object(r) && !w.array(r) && (o = n, n = null);
        var c = Oe(r, n, l);
        for (var p in c) {
          p === "wheel" && (p = oe.wheelEvent);
          for (var h = 0, g = c[p]; h < g.length; h++) {
            var d = g[h];
            pt(p, this._actions) ? this.events[e === Te.On ? "on" : "off"](p, d) : w.string(this.target) ? this._scopeEvents[e === Te.On ? "addDelegate" : "removeDelegate"](this.target, this._context, p, d, o) : this._scopeEvents[e === Te.On ? "add" : "remove"](this.target, p, d, o);
          }
        }
        return this;
      } }, { key: "on", value: function(e, r, n) {
        return this._onOff(Te.On, e, r, n);
      } }, { key: "off", value: function(e, r, n) {
        return this._onOff(Te.Off, e, r, n);
      } }, { key: "set", value: function(e) {
        var r = this._defaults;
        for (var n in w.object(e) || (e = {}), this.options = ke(r.base), this._actions.methodDict) {
          var o = n, l = this._actions.methodDict[o];
          this.options[o] = {}, this.setPerAction(o, W(W({}, r.perAction), r.actions[o])), this[l](e[o]);
        }
        for (var c in e) c !== "getRect" ? w.func(this[c]) && this[c](e[c]) : this.rectChecker(e.getRect);
        return this;
      } }, { key: "unset", value: function() {
        if (w.string(this.target)) for (var e in this._scopeEvents.delegatedEvents) for (var r = this._scopeEvents.delegatedEvents[e], n = r.length - 1; n >= 0; n--) {
          var o = r[n], l = o.selector, c = o.context, p = o.listeners;
          l === this.target && c === this._context && r.splice(n, 1);
          for (var h = p.length - 1; h >= 0; h--) this._scopeEvents.removeDelegate(this.target, this._context, e, p[h][0], p[h][1]);
        }
        else this._scopeEvents.remove(this.target, "all");
      } }]), t;
    }(), No = function() {
      function t(e) {
        var r = this;
        f(this, t), this.list = [], this.selectorMap = {}, this.scope = void 0, this.scope = e, e.addListeners({ "interactable:unset": function(n) {
          var o = n.interactable, l = o.target, c = w.string(l) ? r.selectorMap[l] : l[r.scope.id], p = Ke(c, function(h) {
            return h === o;
          });
          c.splice(p, 1);
        } });
      }
      return y(t, [{ key: "new", value: function(e, r) {
        r = W(r || {}, { actions: this.scope.actions });
        var n = new this.scope.Interactable(e, r, this.scope.document, this.scope.events);
        return this.scope.addDocument(n._doc), this.list.push(n), w.string(e) ? (this.selectorMap[e] || (this.selectorMap[e] = []), this.selectorMap[e].push(n)) : (n.target[this.scope.id] || Object.defineProperty(e, this.scope.id, { value: [], configurable: !0 }), e[this.scope.id].push(n)), this.scope.fire("interactable:new", { target: e, options: r, interactable: n, win: this.scope._win }), n;
      } }, { key: "getExisting", value: function(e, r) {
        var n = r && r.context || this.scope.document, o = w.string(e), l = o ? this.selectorMap[e] : e[this.scope.id];
        if (l) return Xe(l, function(c) {
          return c._context === n && (o || c.inContext(e));
        });
      } }, { key: "forEachMatch", value: function(e, r) {
        for (var n = 0, o = this.list; n < o.length; n++) {
          var l = o[n], c = void 0;
          if ((w.string(l.target) ? w.element(e) && me(e, l.target) : e === l.target) && l.inContext(e) && (c = r(l)), c !== void 0) return c;
        }
      } }]), t;
    }(), Go = function() {
      function t() {
        var e = this;
        f(this, t), this.id = "__interact_scope_".concat(Math.floor(100 * Math.random())), this.isInitialized = !1, this.listenerMaps = [], this.browser = oe, this.defaults = ke(yn), this.Eventable = _n, this.actions = { map: {}, phases: { start: !0, move: !0, end: !0 }, methodDict: {}, phaselessTypes: {} }, this.interactStatic = function(n) {
          var o = function l(c, p) {
            var h = n.interactables.getExisting(c, p);
            return h || ((h = n.interactables.new(c, p)).events.global = l.globalEvents), h;
          };
          return o.getPointerAverage = Jr, o.getTouchBBox = Kt, o.getTouchDistance = Xt, o.getTouchAngle = Bt, o.getElementRect = Nt, o.getElementClientRect = Ut, o.matchesSelector = me, o.closest = Ur, o.globalEvents = {}, o.version = "1.10.27", o.scope = n, o.use = function(l, c) {
            return this.scope.usePlugin(l, c), this;
          }, o.isSet = function(l, c) {
            return !!this.scope.interactables.get(l, c && c.context);
          }, o.on = Be(function(l, c, p) {
            if (w.string(l) && l.search(" ") !== -1 && (l = l.trim().split(/ +/)), w.array(l)) {
              for (var h = 0, g = l; h < g.length; h++) {
                var d = g[h];
                this.on(d, c, p);
              }
              return this;
            }
            if (w.object(l)) {
              for (var b in l) this.on(b, l[b], c);
              return this;
            }
            return pt(l, this.scope.actions) ? this.globalEvents[l] ? this.globalEvents[l].push(c) : this.globalEvents[l] = [c] : this.scope.events.add(this.scope.document, l, c, { options: p }), this;
          }, "The interact.on() method is being deprecated"), o.off = Be(function(l, c, p) {
            if (w.string(l) && l.search(" ") !== -1 && (l = l.trim().split(/ +/)), w.array(l)) {
              for (var h = 0, g = l; h < g.length; h++) {
                var d = g[h];
                this.off(d, c, p);
              }
              return this;
            }
            if (w.object(l)) {
              for (var b in l) this.off(b, l[b], c);
              return this;
            }
            var x;
            return pt(l, this.scope.actions) ? l in this.globalEvents && (x = this.globalEvents[l].indexOf(c)) !== -1 && this.globalEvents[l].splice(x, 1) : this.scope.events.remove(this.scope.document, l, c, p), this;
          }, "The interact.off() method is being deprecated"), o.debug = function() {
            return this.scope;
          }, o.supportsTouch = function() {
            return oe.supportsTouch;
          }, o.supportsPointerEvent = function() {
            return oe.supportsPointerEvent;
          }, o.stop = function() {
            for (var l = 0, c = this.scope.interactions.list; l < c.length; l++) c[l].stop();
            return this;
          }, o.pointerMoveTolerance = function(l) {
            return w.number(l) ? (this.scope.interactions.pointerMoveTolerance = l, this) : this.scope.interactions.pointerMoveTolerance;
          }, o.addDocument = function(l, c) {
            this.scope.addDocument(l, c);
          }, o.removeDocument = function(l) {
            this.scope.removeDocument(l);
          }, o;
        }(this), this.InteractEvent = or, this.Interactable = void 0, this.interactables = new No(this), this._win = void 0, this.document = void 0, this.window = void 0, this.documents = [], this._plugins = { list: [], map: {} }, this.onWindowUnload = function(n) {
          return e.removeDocument(n.target);
        };
        var r = this;
        this.Interactable = function(n) {
          C(l, n);
          var o = P(l);
          function l() {
            return f(this, l), o.apply(this, arguments);
          }
          return y(l, [{ key: "_defaults", get: function() {
            return r.defaults;
          } }, { key: "set", value: function(c) {
            return _(D(l.prototype), "set", this).call(this, c), r.fire("interactable:set", { options: c, interactable: this }), this;
          } }, { key: "unset", value: function() {
            _(D(l.prototype), "unset", this).call(this);
            var c = r.interactables.list.indexOf(this);
            c < 0 || (r.interactables.list.splice(c, 1), r.fire("interactable:unset", { interactable: this }));
          } }]), l;
        }(Uo);
      }
      return y(t, [{ key: "addListeners", value: function(e, r) {
        this.listenerMaps.push({ id: r, map: e });
      } }, { key: "fire", value: function(e, r) {
        for (var n = 0, o = this.listenerMaps; n < o.length; n++) {
          var l = o[n].map[e];
          if (l && l(r, this, e) === !1) return !1;
        }
      } }, { key: "init", value: function(e) {
        return this.isInitialized ? this : function(r, n) {
          return r.isInitialized = !0, w.window(n) && X(n), Q.init(n), oe.init(n), be.init(n), r.window = n, r.document = n.document, r.usePlugin(Fo), r.usePlugin(Lo), r;
        }(this, e);
      } }, { key: "pluginIsInstalled", value: function(e) {
        var r = e.id;
        return r ? !!this._plugins.map[r] : this._plugins.list.indexOf(e) !== -1;
      } }, { key: "usePlugin", value: function(e, r) {
        if (!this.isInitialized) return this;
        if (this.pluginIsInstalled(e)) return this;
        if (e.id && (this._plugins.map[e.id] = e), this._plugins.list.push(e), e.install && e.install(this, r), e.listeners && e.before) {
          for (var n = 0, o = this.listenerMaps.length, l = e.before.reduce(function(p, h) {
            return p[h] = !0, p[Rn(h)] = !0, p;
          }, {}); n < o; n++) {
            var c = this.listenerMaps[n].id;
            if (c && (l[c] || l[Rn(c)])) break;
          }
          this.listenerMaps.splice(n, 0, { id: e.id, map: e.listeners });
        } else e.listeners && this.listenerMaps.push({ id: e.id, map: e.listeners });
        return this;
      } }, { key: "addDocument", value: function(e, r) {
        if (this.getDocIndex(e) !== -1) return !1;
        var n = B(e);
        r = r ? W({}, r) : {}, this.documents.push({ doc: e, options: r }), this.events.documents.push(e), e !== this.document && this.events.add(n, "unload", this.onWindowUnload), this.fire("scope:add-document", { doc: e, window: n, scope: this, options: r });
      } }, { key: "removeDocument", value: function(e) {
        var r = this.getDocIndex(e), n = B(e), o = this.documents[r].options;
        this.events.remove(n, "unload", this.onWindowUnload), this.documents.splice(r, 1), this.events.documents.splice(r, 1), this.fire("scope:remove-document", { doc: e, window: n, scope: this, options: o });
      } }, { key: "getDocIndex", value: function(e) {
        for (var r = 0; r < this.documents.length; r++) if (this.documents[r].doc === e) return r;
        return -1;
      } }, { key: "getDocOptions", value: function(e) {
        var r = this.getDocIndex(e);
        return r === -1 ? null : this.documents[r].options;
      } }, { key: "now", value: function() {
        return (this.window.Date || Date).now();
      } }]), t;
    }();
    function Rn(t) {
      return t && t.replace(/\/.*$/, "");
    }
    var Dn = new Go(), ee = Dn.interactStatic, Yo = typeof globalThis < "u" ? globalThis : window;
    Dn.init(Yo);
    var Ko = Object.freeze({ __proto__: null, edgeTarget: function() {
    }, elements: function() {
    }, grid: function(t) {
      var e = [["x", "y"], ["left", "top"], ["right", "bottom"], ["width", "height"]].filter(function(n) {
        var o = n[0], l = n[1];
        return o in t || l in t;
      }), r = function(n, o) {
        for (var l = t.range, c = t.limits, p = c === void 0 ? { left: -1 / 0, right: 1 / 0, top: -1 / 0, bottom: 1 / 0 } : c, h = t.offset, g = h === void 0 ? { x: 0, y: 0 } : h, d = { range: l, grid: t, x: null, y: null }, b = 0; b < e.length; b++) {
          var x = e[b], I = x[0], E = x[1], M = Math.round((n - g.x) / t[I]), $ = Math.round((o - g.y) / t[E]);
          d[I] = Math.max(p.left, Math.min(p.right, M * t[I] + g.x)), d[E] = Math.max(p.top, Math.min(p.bottom, $ * t[E] + g.y));
        }
        return d;
      };
      return r.grid = t, r.coordFields = e, r;
    } }), Xo = { id: "snappers", install: function(t) {
      var e = t.interactStatic;
      e.snappers = W(e.snappers || {}, Ko), e.createSnapGrid = e.snappers.grid;
    } }, Bo = Xo, Vo = { start: function(t) {
      var e = t.state, r = t.rect, n = t.edges, o = t.pageCoords, l = e.options, c = l.ratio, p = l.enabled, h = e.options, g = h.equalDelta, d = h.modifiers;
      c === "preserve" && (c = r.width / r.height), e.startCoords = W({}, o), e.startRect = W({}, r), e.ratio = c, e.equalDelta = g;
      var b = e.linkedEdges = { top: n.top || n.left && !n.bottom, left: n.left || n.top && !n.right, bottom: n.bottom || n.right && !n.top, right: n.right || n.bottom && !n.left };
      if (e.xIsPrimaryAxis = !(!n.left && !n.right), e.equalDelta) {
        var x = (b.left ? 1 : -1) * (b.top ? 1 : -1);
        e.edgeSign = { x, y: x };
      } else e.edgeSign = { x: b.left ? -1 : 1, y: b.top ? -1 : 1 };
      if (p !== !1 && W(n, b), d != null && d.length) {
        var I = new ir(t.interaction);
        I.copyFrom(t.interaction.modification), I.prepareStates(d), e.subModification = I, I.startAll(u({}, t));
      }
    }, set: function(t) {
      var e = t.state, r = t.rect, n = t.coords, o = e.linkedEdges, l = W({}, n), c = e.equalDelta ? qo : Zo;
      if (W(t.edges, o), c(e, e.xIsPrimaryAxis, n, r), !e.subModification) return null;
      var p = W({}, r);
      ot(o, p, { x: n.x - l.x, y: n.y - l.y });
      var h = e.subModification.setAll(u(u({}, t), {}, { rect: p, edges: o, pageCoords: n, prevCoords: n, prevRect: p })), g = h.delta;
      return h.changed && (c(e, Math.abs(g.x) > Math.abs(g.y), h.coords, h.rect), W(n, h.coords)), h.eventProps;
    }, defaults: { ratio: "preserve", equalDelta: !1, modifiers: [], enabled: !1 } };
    function qo(t, e, r) {
      var n = t.startCoords, o = t.edgeSign;
      e ? r.y = n.y + (r.x - n.x) * o.y : r.x = n.x + (r.y - n.y) * o.x;
    }
    function Zo(t, e, r, n) {
      var o = t.startRect, l = t.startCoords, c = t.ratio, p = t.edgeSign;
      if (e) {
        var h = n.width / c;
        r.y = l.y + (h - o.height) * p.y;
      } else {
        var g = n.height * c;
        r.x = l.x + (g - o.width) * p.x;
      }
    }
    var Jo = ye(Vo, "aspectRatio"), kn = function() {
    };
    kn._defaults = {};
    var vt = kn;
    function Ee(t, e, r) {
      return w.func(t) ? Ue(t, e.interactable, e.element, [r.x, r.y, e]) : Ue(t, e.interactable, e.element);
    }
    var gt = { start: function(t) {
      var e = t.rect, r = t.startOffset, n = t.state, o = t.interaction, l = t.pageCoords, c = n.options, p = c.elementRect, h = W({ left: 0, top: 0, right: 0, bottom: 0 }, c.offset || {});
      if (e && p) {
        var g = Ee(c.restriction, o, l);
        if (g) {
          var d = g.right - g.left - e.width, b = g.bottom - g.top - e.height;
          d < 0 && (h.left += d, h.right += d), b < 0 && (h.top += b, h.bottom += b);
        }
        h.left += r.left - e.width * p.left, h.top += r.top - e.height * p.top, h.right += r.right - e.width * (1 - p.right), h.bottom += r.bottom - e.height * (1 - p.bottom);
      }
      n.offset = h;
    }, set: function(t) {
      var e = t.coords, r = t.interaction, n = t.state, o = n.options, l = n.offset, c = Ee(o.restriction, r, e);
      if (c) {
        var p = function(h) {
          return !h || "left" in h && "top" in h || ((h = W({}, h)).left = h.x || 0, h.top = h.y || 0, h.right = h.right || h.left + h.width, h.bottom = h.bottom || h.top + h.height), h;
        }(c);
        e.x = Math.max(Math.min(p.right - l.right, e.x), p.left + l.left), e.y = Math.max(Math.min(p.bottom - l.bottom, e.y), p.top + l.top);
      }
    }, defaults: { restriction: null, elementRect: null, offset: null, endOnly: !1, enabled: !1 } }, Qo = ye(gt, "restrict"), zn = { top: 1 / 0, left: 1 / 0, bottom: -1 / 0, right: -1 / 0 }, $n = { top: -1 / 0, left: -1 / 0, bottom: 1 / 0, right: 1 / 0 };
    function jn(t, e) {
      for (var r = 0, n = ["top", "left", "bottom", "right"]; r < n.length; r++) {
        var o = n[r];
        o in t || (t[o] = e[o]);
      }
      return t;
    }
    var Ze = { noInner: zn, noOuter: $n, start: function(t) {
      var e, r = t.interaction, n = t.startOffset, o = t.state, l = o.options;
      l && (e = it(Ee(l.offset, r, r.coords.start.page))), e = e || { x: 0, y: 0 }, o.offset = { top: e.y + n.top, left: e.x + n.left, bottom: e.y - n.bottom, right: e.x - n.right };
    }, set: function(t) {
      var e = t.coords, r = t.edges, n = t.interaction, o = t.state, l = o.offset, c = o.options;
      if (r) {
        var p = W({}, e), h = Ee(c.inner, n, p) || {}, g = Ee(c.outer, n, p) || {};
        jn(h, zn), jn(g, $n), r.top ? e.y = Math.min(Math.max(g.top + l.top, p.y), h.top + l.top) : r.bottom && (e.y = Math.max(Math.min(g.bottom + l.bottom, p.y), h.bottom + l.bottom)), r.left ? e.x = Math.min(Math.max(g.left + l.left, p.x), h.left + l.left) : r.right && (e.x = Math.max(Math.min(g.right + l.right, p.x), h.right + l.right));
      }
    }, defaults: { inner: null, outer: null, offset: null, endOnly: !1, enabled: !1 } }, es = ye(Ze, "restrictEdges"), ts = W({ get elementRect() {
      return { top: 0, left: 0, bottom: 1, right: 1 };
    }, set elementRect(t) {
    } }, gt.defaults), rs = ye({ start: gt.start, set: gt.set, defaults: ts }, "restrictRect"), ns = { width: -1 / 0, height: -1 / 0 }, is = { width: 1 / 0, height: 1 / 0 }, os = ye({ start: function(t) {
      return Ze.start(t);
    }, set: function(t) {
      var e = t.interaction, r = t.state, n = t.rect, o = t.edges, l = r.options;
      if (o) {
        var c = Gt(Ee(l.min, e, t.coords)) || ns, p = Gt(Ee(l.max, e, t.coords)) || is;
        r.options = { endOnly: l.endOnly, inner: W({}, Ze.noInner), outer: W({}, Ze.noOuter) }, o.top ? (r.options.inner.top = n.bottom - c.height, r.options.outer.top = n.bottom - p.height) : o.bottom && (r.options.inner.bottom = n.top + c.height, r.options.outer.bottom = n.top + p.height), o.left ? (r.options.inner.left = n.right - c.width, r.options.outer.left = n.right - p.width) : o.right && (r.options.inner.right = n.left + c.width, r.options.outer.right = n.left + p.width), Ze.set(t), r.options = l;
      }
    }, defaults: { min: null, max: null, endOnly: !1, enabled: !1 } }, "restrictSize"), ur = { start: function(t) {
      var e, r = t.interaction, n = t.interactable, o = t.element, l = t.rect, c = t.state, p = t.startOffset, h = c.options, g = h.offsetWithOrigin ? function(x) {
        var I = x.interaction.element, E = it(Ue(x.state.options.origin, null, null, [I])), M = E || Ne(x.interactable, I, x.interaction.prepared.name);
        return M;
      }(t) : { x: 0, y: 0 };
      if (h.offset === "startCoords") e = { x: r.coords.start.page.x, y: r.coords.start.page.y };
      else {
        var d = Ue(h.offset, n, o, [r]);
        (e = it(d) || { x: 0, y: 0 }).x += g.x, e.y += g.y;
      }
      var b = h.relativePoints;
      c.offsets = l && b && b.length ? b.map(function(x, I) {
        return { index: I, relativePoint: x, x: p.left - l.width * x.x + e.x, y: p.top - l.height * x.y + e.y };
      }) : [{ index: 0, relativePoint: null, x: e.x, y: e.y }];
    }, set: function(t) {
      var e = t.interaction, r = t.coords, n = t.state, o = n.options, l = n.offsets, c = Ne(e.interactable, e.element, e.prepared.name), p = W({}, r), h = [];
      o.offsetWithOrigin || (p.x -= c.x, p.y -= c.y);
      for (var g = 0, d = l; g < d.length; g++) for (var b = d[g], x = p.x - b.x, I = p.y - b.y, E = 0, M = o.targets.length; E < M; E++) {
        var $ = o.targets[E], z = void 0;
        (z = w.func($) ? $(x, I, e._proxy, b, E) : $) && h.push({ x: (w.number(z.x) ? z.x : x) + b.x, y: (w.number(z.y) ? z.y : I) + b.y, range: w.number(z.range) ? z.range : o.range, source: $, index: E, offset: b });
      }
      for (var A = { target: null, inRange: !1, distance: 0, range: 0, delta: { x: 0, y: 0 } }, N = 0; N < h.length; N++) {
        var K = h[N], F = K.range, G = K.x - p.x, te = K.y - p.y, J = Ge(G, te), re = J <= F;
        F === 1 / 0 && A.inRange && A.range !== 1 / 0 && (re = !1), A.target && !(re ? A.inRange && F !== 1 / 0 ? J / F < A.distance / A.range : F === 1 / 0 && A.range !== 1 / 0 || J < A.distance : !A.inRange && J < A.distance) || (A.target = K, A.distance = J, A.range = F, A.inRange = re, A.delta.x = G, A.delta.y = te);
      }
      return A.inRange && (r.x = A.target.x, r.y = A.target.y), n.closest = A, A;
    }, defaults: { range: 1 / 0, targets: null, offset: null, offsetWithOrigin: !0, origin: null, relativePoints: null, endOnly: !1, enabled: !1 } }, ss = ye(ur, "snap"), mt = { start: function(t) {
      var e = t.state, r = t.edges, n = e.options;
      if (!r) return null;
      t.state = { options: { targets: null, relativePoints: [{ x: r.left ? 0 : 1, y: r.top ? 0 : 1 }], offset: n.offset || "self", origin: { x: 0, y: 0 }, range: n.range } }, e.targetFields = e.targetFields || [["width", "height"], ["x", "y"]], ur.start(t), e.offsets = t.state.offsets, t.state = e;
    }, set: function(t) {
      var e = t.interaction, r = t.state, n = t.coords, o = r.options, l = r.offsets, c = { x: n.x - l[0].x, y: n.y - l[0].y };
      r.options = W({}, o), r.options.targets = [];
      for (var p = 0, h = o.targets || []; p < h.length; p++) {
        var g = h[p], d = void 0;
        if (d = w.func(g) ? g(c.x, c.y, e) : g) {
          for (var b = 0, x = r.targetFields; b < x.length; b++) {
            var I = x[b], E = I[0], M = I[1];
            if (E in d || M in d) {
              d.x = d[E], d.y = d[M];
              break;
            }
          }
          r.options.targets.push(d);
        }
      }
      var $ = ur.set(t);
      return r.options = o, $;
    }, defaults: { range: 1 / 0, targets: null, offset: null, endOnly: !1, enabled: !1 } }, as = ye(mt, "snapSize"), pr = { aspectRatio: Jo, restrictEdges: es, restrict: Qo, restrictRect: rs, restrictSize: os, snapEdges: ye({ start: function(t) {
      var e = t.edges;
      return e ? (t.state.targetFields = t.state.targetFields || [[e.left ? "left" : "right", e.top ? "top" : "bottom"]], mt.start(t)) : null;
    }, set: mt.set, defaults: W(ke(mt.defaults), { targets: void 0, range: void 0, offset: { x: 0, y: 0 } }) }, "snapEdges"), snap: ss, snapSize: as, spring: vt, avoid: vt, transform: vt, rubberband: vt }, ls = { id: "modifiers", install: function(t) {
      var e = t.interactStatic;
      for (var r in t.usePlugin(bn), t.usePlugin(Bo), e.modifiers = pr, pr) {
        var n = pr[r], o = n._defaults, l = n._methods;
        o._methods = l, t.defaults.perAction[r] = o;
      }
    } }, cs = ls, An = function(t) {
      C(r, t);
      var e = P(r);
      function r(n, o, l, c, p, h) {
        var g;
        if (f(this, r), st(T(g = e.call(this, p)), l), l !== o && st(T(g), o), g.timeStamp = h, g.originalEvent = l, g.type = n, g.pointerId = Ye(o), g.pointerType = Qr(o), g.target = c, g.currentTarget = null, n === "tap") {
          var d = p.getPointerIndex(o);
          g.dt = g.timeStamp - p.pointers[d].downTime;
          var b = g.timeStamp - p.tapTime;
          g.double = !!p.prevTap && p.prevTap.type !== "doubletap" && p.prevTap.target === g.target && b < 500;
        } else n === "doubletap" && (g.dt = o.timeStamp - p.tapTime, g.double = !0);
        return g;
      }
      return y(r, [{ key: "_subtractOrigin", value: function(n) {
        var o = n.x, l = n.y;
        return this.pageX -= o, this.pageY -= l, this.clientX -= o, this.clientY -= l, this;
      } }, { key: "_addOrigin", value: function(n) {
        var o = n.x, l = n.y;
        return this.pageX += o, this.pageY += l, this.clientX += o, this.clientY += l, this;
      } }, { key: "preventDefault", value: function() {
        this.originalEvent.preventDefault();
      } }]), r;
    }(ct), Je = { id: "pointer-events/base", before: ["inertia", "modifiers", "auto-start", "actions"], install: function(t) {
      t.pointerEvents = Je, t.defaults.actions.pointerEvents = Je.defaults, W(t.actions.phaselessTypes, Je.types);
    }, listeners: { "interactions:new": function(t) {
      var e = t.interaction;
      e.prevTap = null, e.tapTime = 0;
    }, "interactions:update-pointer": function(t) {
      var e = t.down, r = t.pointerInfo;
      !e && r.hold || (r.hold = { duration: 1 / 0, timeout: null });
    }, "interactions:move": function(t, e) {
      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget;
      t.duplicate || r.pointerIsDown && !r.pointerWasMoved || (r.pointerIsDown && hr(t), we({ interaction: r, pointer: n, event: o, eventTarget: l, type: "move" }, e));
    }, "interactions:down": function(t, e) {
      (function(r, n) {
        for (var o = r.interaction, l = r.pointer, c = r.event, p = r.eventTarget, h = r.pointerIndex, g = o.pointers[h].hold, d = Yr(p), b = { interaction: o, pointer: l, event: c, eventTarget: p, type: "hold", targets: [], path: d, node: null }, x = 0; x < d.length; x++) {
          var I = d[x];
          b.node = I, n.fire("pointerEvents:collect-targets", b);
        }
        if (b.targets.length) {
          for (var E = 1 / 0, M = 0, $ = b.targets; M < $.length; M++) {
            var z = $[M].eventable.options.holdDuration;
            z < E && (E = z);
          }
          g.duration = E, g.timeout = setTimeout(function() {
            we({ interaction: o, eventTarget: p, pointer: l, event: c, type: "hold" }, n);
          }, E);
        }
      })(t, e), we(t, e);
    }, "interactions:up": function(t, e) {
      hr(t), we(t, e), function(r, n) {
        var o = r.interaction, l = r.pointer, c = r.event, p = r.eventTarget;
        o.pointerWasMoved || we({ interaction: o, eventTarget: p, pointer: l, event: c, type: "tap" }, n);
      }(t, e);
    }, "interactions:cancel": function(t, e) {
      hr(t), we(t, e);
    } }, PointerEvent: An, fire: we, collectEventTargets: Ln, defaults: { holdDuration: 600, ignoreFrom: null, allowFrom: null, origin: { x: 0, y: 0 } }, types: { down: !0, move: !0, up: !0, cancel: !0, tap: !0, doubletap: !0, hold: !0 } };
    function we(t, e) {
      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget, c = t.type, p = t.targets, h = p === void 0 ? Ln(t, e) : p, g = new An(c, n, o, l, r, e.now());
      e.fire("pointerEvents:new", { pointerEvent: g });
      for (var d = { interaction: r, pointer: n, event: o, eventTarget: l, targets: h, type: c, pointerEvent: g }, b = 0; b < h.length; b++) {
        var x = h[b];
        for (var I in x.props || {}) g[I] = x.props[I];
        var E = Ne(x.eventable, x.node);
        if (g._subtractOrigin(E), g.eventable = x.eventable, g.currentTarget = x.node, x.eventable.fire(g), g._addOrigin(E), g.immediatePropagationStopped || g.propagationStopped && b + 1 < h.length && h[b + 1].node !== g.currentTarget) break;
      }
      if (e.fire("pointerEvents:fired", d), c === "tap") {
        var M = g.double ? we({ interaction: r, pointer: n, event: o, eventTarget: l, type: "doubletap" }, e) : g;
        r.prevTap = M, r.tapTime = M.timeStamp;
      }
      return g;
    }
    function Ln(t, e) {
      var r = t.interaction, n = t.pointer, o = t.event, l = t.eventTarget, c = t.type, p = r.getPointerIndex(n), h = r.pointers[p];
      if (c === "tap" && (r.pointerWasMoved || !h || h.downTarget !== l)) return [];
      for (var g = Yr(l), d = { interaction: r, pointer: n, event: o, eventTarget: l, type: c, path: g, targets: [], node: null }, b = 0; b < g.length; b++) {
        var x = g[b];
        d.node = x, e.fire("pointerEvents:collect-targets", d);
      }
      return c === "hold" && (d.targets = d.targets.filter(function(I) {
        var E, M;
        return I.eventable.options.holdDuration === ((E = r.pointers[p]) == null || (M = E.hold) == null ? void 0 : M.duration);
      })), d.targets;
    }
    function hr(t) {
      var e = t.interaction, r = t.pointerIndex, n = e.pointers[r].hold;
      n && n.timeout && (clearTimeout(n.timeout), n.timeout = null);
    }
    var us = Object.freeze({ __proto__: null, default: Je });
    function ps(t) {
      var e = t.interaction;
      e.holdIntervalHandle && (clearInterval(e.holdIntervalHandle), e.holdIntervalHandle = null);
    }
    var hs = { id: "pointer-events/holdRepeat", install: function(t) {
      t.usePlugin(Je);
      var e = t.pointerEvents;
      e.defaults.holdRepeatInterval = 0, e.types.holdrepeat = t.actions.phaselessTypes.holdrepeat = !0;
    }, listeners: ["move", "up", "cancel", "endall"].reduce(function(t, e) {
      return t["pointerEvents:".concat(e)] = ps, t;
    }, { "pointerEvents:new": function(t) {
      var e = t.pointerEvent;
      e.type === "hold" && (e.count = (e.count || 0) + 1);
    }, "pointerEvents:fired": function(t, e) {
      var r = t.interaction, n = t.pointerEvent, o = t.eventTarget, l = t.targets;
      if (n.type === "hold" && l.length) {
        var c = l[0].eventable.options.holdRepeatInterval;
        c <= 0 || (r.holdIntervalHandle = setTimeout(function() {
          e.pointerEvents.fire({ interaction: r, eventTarget: o, type: "hold", pointer: n, event: n }, e);
        }, c));
      }
    } }) }, ds = hs, fs = { id: "pointer-events/interactableTargets", install: function(t) {
      var e = t.Interactable;
      e.prototype.pointerEvents = function(n) {
        return W(this.events.options, n), this;
      };
      var r = e.prototype._backCompatOption;
      e.prototype._backCompatOption = function(n, o) {
        var l = r.call(this, n, o);
        return l === this && (this.events.options[n] = o), l;
      };
    }, listeners: { "pointerEvents:collect-targets": function(t, e) {
      var r = t.targets, n = t.node, o = t.type, l = t.eventTarget;
      e.interactables.forEachMatch(n, function(c) {
        var p = c.events, h = p.options;
        p.types[o] && p.types[o].length && c.testIgnoreAllow(h, n, l) && r.push({ node: n, eventable: p, props: { interactable: c } });
      });
    }, "interactable:new": function(t) {
      var e = t.interactable;
      e.events.getRect = function(r) {
        return e.getRect(r);
      };
    }, "interactable:set": function(t, e) {
      var r = t.interactable, n = t.options;
      W(r.events.options, e.pointerEvents.defaults), W(r.events.options, n.pointerEvents || {});
    } } }, vs = fs, gs = { id: "pointer-events", install: function(t) {
      t.usePlugin(us), t.usePlugin(ds), t.usePlugin(vs);
    } }, ms = gs, bs = { id: "reflow", install: function(t) {
      var e = t.Interactable;
      t.actions.phases.reflow = !0, e.prototype.reflow = function(r) {
        return function(n, o, l) {
          for (var c = n.getAllElements(), p = l.window.Promise, h = p ? [] : null, g = function() {
            var b = c[d], x = n.getRect(b);
            if (!x) return 1;
            var I, E = Xe(l.interactions.list, function(z) {
              return z.interacting() && z.interactable === n && z.element === b && z.prepared.name === o.name;
            });
            if (E) E.move(), h && (I = E._reflowPromise || new p(function(z) {
              E._reflowResolve = z;
            }));
            else {
              var M = Gt(x), $ = /* @__PURE__ */ function(z) {
                return { coords: z, get page() {
                  return this.coords.page;
                }, get client() {
                  return this.coords.client;
                }, get timeStamp() {
                  return this.coords.timeStamp;
                }, get pageX() {
                  return this.coords.page.x;
                }, get pageY() {
                  return this.coords.page.y;
                }, get clientX() {
                  return this.coords.client.x;
                }, get clientY() {
                  return this.coords.client.y;
                }, get pointerId() {
                  return this.coords.pointerId;
                }, get target() {
                  return this.coords.target;
                }, get type() {
                  return this.coords.type;
                }, get pointerType() {
                  return this.coords.pointerType;
                }, get buttons() {
                  return this.coords.buttons;
                }, preventDefault: function() {
                } };
              }({ page: { x: M.x, y: M.y }, client: { x: M.x, y: M.y }, timeStamp: l.now() });
              I = function(z, A, N, K, F) {
                var G = z.interactions.new({ pointerType: "reflow" }), te = { interaction: G, event: F, pointer: F, eventTarget: N, phase: "reflow" };
                G.interactable = A, G.element = N, G.prevEvent = F, G.updatePointer(F, F, N, !0), Vr(G.coords.delta), er(G.prepared, K), G._doPhase(te);
                var J = z.window, re = J.Promise, se = re ? new re(function(fe) {
                  G._reflowResolve = fe;
                }) : void 0;
                return G._reflowPromise = se, G.start(K, A, N), G._interacting ? (G.move(te), G.end(F)) : (G.stop(), G._reflowResolve()), G.removePointer(F, F), se;
              }(l, n, b, o, $);
            }
            h && h.push(I);
          }, d = 0; d < c.length && !g(); d++) ;
          return h && p.all(h).then(function() {
            return n;
          });
        }(this, r, t);
      };
    }, listeners: { "interactions:stop": function(t, e) {
      var r = t.interaction;
      r.pointerType === "reflow" && (r._reflowResolve && r._reflowResolve(), function(n, o) {
        n.splice(n.indexOf(o), 1);
      }(e.interactions.list, r));
    } } }, ys = bs;
    if (ee.use(mn), ee.use(Sn), ee.use(ms), ee.use(jo), ee.use(cs), ee.use(Oo), ee.use(ho), ee.use(vo), ee.use(ys), ee.default = ee, v(a) === "object" && a) try {
      a.exports = ee;
    } catch {
    }
    return ee.default = ee, ee;
  });
})(Et, Et.exports);
var ws = Et.exports;
const dr = /* @__PURE__ */ rt(ws);
var Si = { exports: {} };
(function(a, i) {
  (function(s, u) {
    a.exports = u();
  })(Ie, function() {
    var s = "minute", u = /[+-]\d\d(?::?\d\d)?/g, v = /([+-]|\d\d)/g;
    return function(f, m, y) {
      var S = m.prototype;
      y.utc = function(O) {
        var k = { date: O, utc: !0, args: arguments };
        return new m(k);
      }, S.utc = function(O) {
        var k = y(this.toDate(), { locale: this.$L, utc: !0 });
        return O ? k.add(this.utcOffset(), s) : k;
      }, S.local = function() {
        return y(this.toDate(), { locale: this.$L, utc: !1 });
      };
      var C = S.parse;
      S.parse = function(O) {
        O.utc && (this.$u = !0), this.$utils().u(O.$offset) || (this.$offset = O.$offset), C.call(this, O);
      };
      var D = S.init;
      S.init = function() {
        if (this.$u) {
          var O = this.$d;
          this.$y = O.getUTCFullYear(), this.$M = O.getUTCMonth(), this.$D = O.getUTCDate(), this.$W = O.getUTCDay(), this.$H = O.getUTCHours(), this.$m = O.getUTCMinutes(), this.$s = O.getUTCSeconds(), this.$ms = O.getUTCMilliseconds();
        } else D.call(this);
      };
      var R = S.utcOffset;
      S.utcOffset = function(O, k) {
        var L = this.$utils().u;
        if (L(O)) return this.$u ? 0 : L(this.$offset) ? R.call(this) : this.$offset;
        if (typeof O == "string" && (O = function(V) {
          V === void 0 && (V = "");
          var le = V.match(u);
          if (!le) return null;
          var w = ("" + le[0]).match(v) || ["-", 0, 0], ce = w[0], Me = 60 * +w[1] + +w[2];
          return Me === 0 ? 0 : ce === "+" ? Me : -Me;
        }(O), O === null)) return this;
        var H = Math.abs(O) <= 16 ? 60 * O : O;
        if (H === 0) return this.utc(k);
        var X = this.clone();
        if (k) return X.$offset = H, X.$u = !1, X;
        var B = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
        return (X = this.local().add(H + B, s)).$offset = H, X.$x.$localOffset = B, X;
      };
      var T = S.format;
      S.format = function(O) {
        var k = O || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
        return T.call(this, k);
      }, S.valueOf = function() {
        var O = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
        return this.$d.valueOf() - 6e4 * O;
      }, S.isUTC = function() {
        return !!this.$u;
      }, S.toISOString = function() {
        return this.toDate().toISOString();
      }, S.toString = function() {
        return this.toDate().toUTCString();
      };
      var P = S.toDate;
      S.toDate = function(O) {
        return O === "s" && this.$offset ? y(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : P.call(this);
      };
      var _ = S.diff;
      S.diff = function(O, k, L) {
        if (O && this.$u === O.$u) return _.call(this, O, k, L);
        var H = this.local(), X = y(O).local();
        return _.call(H, X, k, L);
      };
    };
  });
})(Si);
var xs = Si.exports;
const Ss = /* @__PURE__ */ rt(xs);
function Os() {
  this.__data__ = [], this.size = 0;
}
var Cs = Os;
function Es(a, i) {
  return a === i || a !== a && i !== i;
}
var Oi = Es, _s = Oi;
function Ps(a, i) {
  for (var s = a.length; s--; )
    if (_s(a[s][0], i))
      return s;
  return -1;
}
var Dt = Ps, Is = Dt, Ms = Array.prototype, Rs = Ms.splice;
function Ds(a) {
  var i = this.__data__, s = Is(i, a);
  if (s < 0)
    return !1;
  var u = i.length - 1;
  return s == u ? i.pop() : Rs.call(i, s, 1), --this.size, !0;
}
var ks = Ds, zs = Dt;
function $s(a) {
  var i = this.__data__, s = zs(i, a);
  return s < 0 ? void 0 : i[s][1];
}
var js = $s, As = Dt;
function Ls(a) {
  return As(this.__data__, a) > -1;
}
var Hs = Ls, Ws = Dt;
function Fs(a, i) {
  var s = this.__data__, u = Ws(s, a);
  return u < 0 ? (++this.size, s.push([a, i])) : s[u][1] = i, this;
}
var Us = Fs, Ns = Cs, Gs = ks, Ys = js, Ks = Hs, Xs = Us;
function je(a) {
  var i = -1, s = a == null ? 0 : a.length;
  for (this.clear(); ++i < s; ) {
    var u = a[i];
    this.set(u[0], u[1]);
  }
}
je.prototype.clear = Ns;
je.prototype.delete = Gs;
je.prototype.get = Ys;
je.prototype.has = Ks;
je.prototype.set = Xs;
var kt = je, Bs = kt;
function Vs() {
  this.__data__ = new Bs(), this.size = 0;
}
var qs = Vs;
function Zs(a) {
  var i = this.__data__, s = i.delete(a);
  return this.size = i.size, s;
}
var Js = Zs;
function Qs(a) {
  return this.__data__.get(a);
}
var ea = Qs;
function ta(a) {
  return this.__data__.has(a);
}
var ra = ta, na = typeof Ie == "object" && Ie && Ie.Object === Object && Ie, Ci = na, ia = Ci, oa = typeof self == "object" && self && self.Object === Object && self, sa = ia || oa || Function("return this")(), ge = sa, aa = ge, la = aa.Symbol, _r = la, Wn = _r, Ei = Object.prototype, ca = Ei.hasOwnProperty, ua = Ei.toString, et = Wn ? Wn.toStringTag : void 0;
function pa(a) {
  var i = ca.call(a, et), s = a[et];
  try {
    a[et] = void 0;
    var u = !0;
  } catch {
  }
  var v = ua.call(a);
  return u && (i ? a[et] = s : delete a[et]), v;
}
var ha = pa, da = Object.prototype, fa = da.toString;
function va(a) {
  return fa.call(a);
}
var ga = va, Fn = _r, ma = ha, ba = ga, ya = "[object Null]", Ta = "[object Undefined]", Un = Fn ? Fn.toStringTag : void 0;
function wa(a) {
  return a == null ? a === void 0 ? Ta : ya : Un && Un in Object(a) ? ma(a) : ba(a);
}
var zt = wa;
function xa(a) {
  var i = typeof a;
  return a != null && (i == "object" || i == "function");
}
var _i = xa, Sa = zt, Oa = _i, Ca = "[object AsyncFunction]", Ea = "[object Function]", _a = "[object GeneratorFunction]", Pa = "[object Proxy]";
function Ia(a) {
  if (!Oa(a))
    return !1;
  var i = Sa(a);
  return i == Ea || i == _a || i == Ca || i == Pa;
}
var Pi = Ia, Ma = ge, Ra = Ma["__core-js_shared__"], Da = Ra, fr = Da, Nn = function() {
  var a = /[^.]+$/.exec(fr && fr.keys && fr.keys.IE_PROTO || "");
  return a ? "Symbol(src)_1." + a : "";
}();
function ka(a) {
  return !!Nn && Nn in a;
}
var za = ka, $a = Function.prototype, ja = $a.toString;
function Aa(a) {
  if (a != null) {
    try {
      return ja.call(a);
    } catch {
    }
    try {
      return a + "";
    } catch {
    }
  }
  return "";
}
var Ii = Aa, La = Pi, Ha = za, Wa = _i, Fa = Ii, Ua = /[\\^$.*+?()[\]{}|]/g, Na = /^\[object .+?Constructor\]$/, Ga = Function.prototype, Ya = Object.prototype, Ka = Ga.toString, Xa = Ya.hasOwnProperty, Ba = RegExp(
  "^" + Ka.call(Xa).replace(Ua, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Va(a) {
  if (!Wa(a) || Ha(a))
    return !1;
  var i = La(a) ? Ba : Na;
  return i.test(Fa(a));
}
var qa = Va;
function Za(a, i) {
  return a == null ? void 0 : a[i];
}
var Ja = Za, Qa = qa, el = Ja;
function tl(a, i) {
  var s = el(a, i);
  return Qa(s) ? s : void 0;
}
var Ae = tl, rl = Ae, nl = ge, il = rl(nl, "Map"), Pr = il, ol = Ae, sl = ol(Object, "create"), $t = sl, Gn = $t;
function al() {
  this.__data__ = Gn ? Gn(null) : {}, this.size = 0;
}
var ll = al;
function cl(a) {
  var i = this.has(a) && delete this.__data__[a];
  return this.size -= i ? 1 : 0, i;
}
var ul = cl, pl = $t, hl = "__lodash_hash_undefined__", dl = Object.prototype, fl = dl.hasOwnProperty;
function vl(a) {
  var i = this.__data__;
  if (pl) {
    var s = i[a];
    return s === hl ? void 0 : s;
  }
  return fl.call(i, a) ? i[a] : void 0;
}
var gl = vl, ml = $t, bl = Object.prototype, yl = bl.hasOwnProperty;
function Tl(a) {
  var i = this.__data__;
  return ml ? i[a] !== void 0 : yl.call(i, a);
}
var wl = Tl, xl = $t, Sl = "__lodash_hash_undefined__";
function Ol(a, i) {
  var s = this.__data__;
  return this.size += this.has(a) ? 0 : 1, s[a] = xl && i === void 0 ? Sl : i, this;
}
var Cl = Ol, El = ll, _l = ul, Pl = gl, Il = wl, Ml = Cl;
function Le(a) {
  var i = -1, s = a == null ? 0 : a.length;
  for (this.clear(); ++i < s; ) {
    var u = a[i];
    this.set(u[0], u[1]);
  }
}
Le.prototype.clear = El;
Le.prototype.delete = _l;
Le.prototype.get = Pl;
Le.prototype.has = Il;
Le.prototype.set = Ml;
var Rl = Le, Yn = Rl, Dl = kt, kl = Pr;
function zl() {
  this.size = 0, this.__data__ = {
    hash: new Yn(),
    map: new (kl || Dl)(),
    string: new Yn()
  };
}
var $l = zl;
function jl(a) {
  var i = typeof a;
  return i == "string" || i == "number" || i == "symbol" || i == "boolean" ? a !== "__proto__" : a === null;
}
var Al = jl, Ll = Al;
function Hl(a, i) {
  var s = a.__data__;
  return Ll(i) ? s[typeof i == "string" ? "string" : "hash"] : s.map;
}
var jt = Hl, Wl = jt;
function Fl(a) {
  var i = Wl(this, a).delete(a);
  return this.size -= i ? 1 : 0, i;
}
var Ul = Fl, Nl = jt;
function Gl(a) {
  return Nl(this, a).get(a);
}
var Yl = Gl, Kl = jt;
function Xl(a) {
  return Kl(this, a).has(a);
}
var Bl = Xl, Vl = jt;
function ql(a, i) {
  var s = Vl(this, a), u = s.size;
  return s.set(a, i), this.size += s.size == u ? 0 : 1, this;
}
var Zl = ql, Jl = $l, Ql = Ul, ec = Yl, tc = Bl, rc = Zl;
function He(a) {
  var i = -1, s = a == null ? 0 : a.length;
  for (this.clear(); ++i < s; ) {
    var u = a[i];
    this.set(u[0], u[1]);
  }
}
He.prototype.clear = Jl;
He.prototype.delete = Ql;
He.prototype.get = ec;
He.prototype.has = tc;
He.prototype.set = rc;
var Mi = He, nc = kt, ic = Pr, oc = Mi, sc = 200;
function ac(a, i) {
  var s = this.__data__;
  if (s instanceof nc) {
    var u = s.__data__;
    if (!ic || u.length < sc - 1)
      return u.push([a, i]), this.size = ++s.size, this;
    s = this.__data__ = new oc(u);
  }
  return s.set(a, i), this.size = s.size, this;
}
var lc = ac, cc = kt, uc = qs, pc = Js, hc = ea, dc = ra, fc = lc;
function We(a) {
  var i = this.__data__ = new cc(a);
  this.size = i.size;
}
We.prototype.clear = uc;
We.prototype.delete = pc;
We.prototype.get = hc;
We.prototype.has = dc;
We.prototype.set = fc;
var vc = We, gc = "__lodash_hash_undefined__";
function mc(a) {
  return this.__data__.set(a, gc), this;
}
var bc = mc;
function yc(a) {
  return this.__data__.has(a);
}
var Tc = yc, wc = Mi, xc = bc, Sc = Tc;
function _t(a) {
  var i = -1, s = a == null ? 0 : a.length;
  for (this.__data__ = new wc(); ++i < s; )
    this.add(a[i]);
}
_t.prototype.add = _t.prototype.push = xc;
_t.prototype.has = Sc;
var Oc = _t;
function Cc(a, i) {
  for (var s = -1, u = a == null ? 0 : a.length; ++s < u; )
    if (i(a[s], s, a))
      return !0;
  return !1;
}
var Ec = Cc;
function _c(a, i) {
  return a.has(i);
}
var Pc = _c, Ic = Oc, Mc = Ec, Rc = Pc, Dc = 1, kc = 2;
function zc(a, i, s, u, v, f) {
  var m = s & Dc, y = a.length, S = i.length;
  if (y != S && !(m && S > y))
    return !1;
  var C = f.get(a), D = f.get(i);
  if (C && D)
    return C == i && D == a;
  var R = -1, T = !0, P = s & kc ? new Ic() : void 0;
  for (f.set(a, i), f.set(i, a); ++R < y; ) {
    var _ = a[R], O = i[R];
    if (u)
      var k = m ? u(O, _, R, i, a, f) : u(_, O, R, a, i, f);
    if (k !== void 0) {
      if (k)
        continue;
      T = !1;
      break;
    }
    if (P) {
      if (!Mc(i, function(L, H) {
        if (!Rc(P, H) && (_ === L || v(_, L, s, u, f)))
          return P.push(H);
      })) {
        T = !1;
        break;
      }
    } else if (!(_ === O || v(_, O, s, u, f))) {
      T = !1;
      break;
    }
  }
  return f.delete(a), f.delete(i), T;
}
var Ri = zc, $c = ge, jc = $c.Uint8Array, Ac = jc;
function Lc(a) {
  var i = -1, s = Array(a.size);
  return a.forEach(function(u, v) {
    s[++i] = [v, u];
  }), s;
}
var Hc = Lc;
function Wc(a) {
  var i = -1, s = Array(a.size);
  return a.forEach(function(u) {
    s[++i] = u;
  }), s;
}
var Fc = Wc, Kn = _r, Xn = Ac, Uc = Oi, Nc = Ri, Gc = Hc, Yc = Fc, Kc = 1, Xc = 2, Bc = "[object Boolean]", Vc = "[object Date]", qc = "[object Error]", Zc = "[object Map]", Jc = "[object Number]", Qc = "[object RegExp]", eu = "[object Set]", tu = "[object String]", ru = "[object Symbol]", nu = "[object ArrayBuffer]", iu = "[object DataView]", Bn = Kn ? Kn.prototype : void 0, vr = Bn ? Bn.valueOf : void 0;
function ou(a, i, s, u, v, f, m) {
  switch (s) {
    case iu:
      if (a.byteLength != i.byteLength || a.byteOffset != i.byteOffset)
        return !1;
      a = a.buffer, i = i.buffer;
    case nu:
      return !(a.byteLength != i.byteLength || !f(new Xn(a), new Xn(i)));
    case Bc:
    case Vc:
    case Jc:
      return Uc(+a, +i);
    case qc:
      return a.name == i.name && a.message == i.message;
    case Qc:
    case tu:
      return a == i + "";
    case Zc:
      var y = Gc;
    case eu:
      var S = u & Kc;
      if (y || (y = Yc), a.size != i.size && !S)
        return !1;
      var C = m.get(a);
      if (C)
        return C == i;
      u |= Xc, m.set(a, i);
      var D = Nc(y(a), y(i), u, v, f, m);
      return m.delete(a), D;
    case ru:
      if (vr)
        return vr.call(a) == vr.call(i);
  }
  return !1;
}
var su = ou;
function au(a, i) {
  for (var s = -1, u = i.length, v = a.length; ++s < u; )
    a[v + s] = i[s];
  return a;
}
var lu = au, cu = Array.isArray, Ir = cu, uu = lu, pu = Ir;
function hu(a, i, s) {
  var u = i(a);
  return pu(a) ? u : uu(u, s(a));
}
var du = hu;
function fu(a, i) {
  for (var s = -1, u = a == null ? 0 : a.length, v = 0, f = []; ++s < u; ) {
    var m = a[s];
    i(m, s, a) && (f[v++] = m);
  }
  return f;
}
var vu = fu;
function gu() {
  return [];
}
var mu = gu, bu = vu, yu = mu, Tu = Object.prototype, wu = Tu.propertyIsEnumerable, Vn = Object.getOwnPropertySymbols, xu = Vn ? function(a) {
  return a == null ? [] : (a = Object(a), bu(Vn(a), function(i) {
    return wu.call(a, i);
  }));
} : yu, Su = xu;
function Ou(a, i) {
  for (var s = -1, u = Array(a); ++s < a; )
    u[s] = i(s);
  return u;
}
var Cu = Ou;
function Eu(a) {
  return a != null && typeof a == "object";
}
var At = Eu, _u = zt, Pu = At, Iu = "[object Arguments]";
function Mu(a) {
  return Pu(a) && _u(a) == Iu;
}
var Ru = Mu, qn = Ru, Du = At, Di = Object.prototype, ku = Di.hasOwnProperty, zu = Di.propertyIsEnumerable, $u = qn(/* @__PURE__ */ function() {
  return arguments;
}()) ? qn : function(a) {
  return Du(a) && ku.call(a, "callee") && !zu.call(a, "callee");
}, ju = $u, Pt = { exports: {} };
function Au() {
  return !1;
}
var Lu = Au;
Pt.exports;
(function(a, i) {
  var s = ge, u = Lu, v = i && !i.nodeType && i, f = v && !0 && a && !a.nodeType && a, m = f && f.exports === v, y = m ? s.Buffer : void 0, S = y ? y.isBuffer : void 0, C = S || u;
  a.exports = C;
})(Pt, Pt.exports);
var ki = Pt.exports, Hu = 9007199254740991, Wu = /^(?:0|[1-9]\d*)$/;
function Fu(a, i) {
  var s = typeof a;
  return i = i ?? Hu, !!i && (s == "number" || s != "symbol" && Wu.test(a)) && a > -1 && a % 1 == 0 && a < i;
}
var Uu = Fu, Nu = 9007199254740991;
function Gu(a) {
  return typeof a == "number" && a > -1 && a % 1 == 0 && a <= Nu;
}
var zi = Gu, Yu = zt, Ku = zi, Xu = At, Bu = "[object Arguments]", Vu = "[object Array]", qu = "[object Boolean]", Zu = "[object Date]", Ju = "[object Error]", Qu = "[object Function]", ep = "[object Map]", tp = "[object Number]", rp = "[object Object]", np = "[object RegExp]", ip = "[object Set]", op = "[object String]", sp = "[object WeakMap]", ap = "[object ArrayBuffer]", lp = "[object DataView]", cp = "[object Float32Array]", up = "[object Float64Array]", pp = "[object Int8Array]", hp = "[object Int16Array]", dp = "[object Int32Array]", fp = "[object Uint8Array]", vp = "[object Uint8ClampedArray]", gp = "[object Uint16Array]", mp = "[object Uint32Array]", q = {};
q[cp] = q[up] = q[pp] = q[hp] = q[dp] = q[fp] = q[vp] = q[gp] = q[mp] = !0;
q[Bu] = q[Vu] = q[ap] = q[qu] = q[lp] = q[Zu] = q[Ju] = q[Qu] = q[ep] = q[tp] = q[rp] = q[np] = q[ip] = q[op] = q[sp] = !1;
function bp(a) {
  return Xu(a) && Ku(a.length) && !!q[Yu(a)];
}
var yp = bp;
function Tp(a) {
  return function(i) {
    return a(i);
  };
}
var wp = Tp, It = { exports: {} };
It.exports;
(function(a, i) {
  var s = Ci, u = i && !i.nodeType && i, v = u && !0 && a && !a.nodeType && a, f = v && v.exports === u, m = f && s.process, y = function() {
    try {
      var S = v && v.require && v.require("util").types;
      return S || m && m.binding && m.binding("util");
    } catch {
    }
  }();
  a.exports = y;
})(It, It.exports);
var xp = It.exports, Sp = yp, Op = wp, Zn = xp, Jn = Zn && Zn.isTypedArray, Cp = Jn ? Op(Jn) : Sp, $i = Cp, Ep = Cu, _p = ju, Pp = Ir, Ip = ki, Mp = Uu, Rp = $i, Dp = Object.prototype, kp = Dp.hasOwnProperty;
function zp(a, i) {
  var s = Pp(a), u = !s && _p(a), v = !s && !u && Ip(a), f = !s && !u && !v && Rp(a), m = s || u || v || f, y = m ? Ep(a.length, String) : [], S = y.length;
  for (var C in a)
    (i || kp.call(a, C)) && !(m && // Safari 9 has enumerable `arguments.length` in strict mode.
    (C == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    v && (C == "offset" || C == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    f && (C == "buffer" || C == "byteLength" || C == "byteOffset") || // Skip index properties.
    Mp(C, S))) && y.push(C);
  return y;
}
var $p = zp, jp = Object.prototype;
function Ap(a) {
  var i = a && a.constructor, s = typeof i == "function" && i.prototype || jp;
  return a === s;
}
var Lp = Ap;
function Hp(a, i) {
  return function(s) {
    return a(i(s));
  };
}
var Wp = Hp, Fp = Wp, Up = Fp(Object.keys, Object), Np = Up, Gp = Lp, Yp = Np, Kp = Object.prototype, Xp = Kp.hasOwnProperty;
function Bp(a) {
  if (!Gp(a))
    return Yp(a);
  var i = [];
  for (var s in Object(a))
    Xp.call(a, s) && s != "constructor" && i.push(s);
  return i;
}
var Vp = Bp, qp = Pi, Zp = zi;
function Jp(a) {
  return a != null && Zp(a.length) && !qp(a);
}
var Qp = Jp, eh = $p, th = Vp, rh = Qp;
function nh(a) {
  return rh(a) ? eh(a) : th(a);
}
var ih = nh, oh = du, sh = Su, ah = ih;
function lh(a) {
  return oh(a, ah, sh);
}
var ch = lh, Qn = ch, uh = 1, ph = Object.prototype, hh = ph.hasOwnProperty;
function dh(a, i, s, u, v, f) {
  var m = s & uh, y = Qn(a), S = y.length, C = Qn(i), D = C.length;
  if (S != D && !m)
    return !1;
  for (var R = S; R--; ) {
    var T = y[R];
    if (!(m ? T in i : hh.call(i, T)))
      return !1;
  }
  var P = f.get(a), _ = f.get(i);
  if (P && _)
    return P == i && _ == a;
  var O = !0;
  f.set(a, i), f.set(i, a);
  for (var k = m; ++R < S; ) {
    T = y[R];
    var L = a[T], H = i[T];
    if (u)
      var X = m ? u(H, L, T, i, a, f) : u(L, H, T, a, i, f);
    if (!(X === void 0 ? L === H || v(L, H, s, u, f) : X)) {
      O = !1;
      break;
    }
    k || (k = T == "constructor");
  }
  if (O && !k) {
    var B = a.constructor, V = i.constructor;
    B != V && "constructor" in a && "constructor" in i && !(typeof B == "function" && B instanceof B && typeof V == "function" && V instanceof V) && (O = !1);
  }
  return f.delete(a), f.delete(i), O;
}
var fh = dh, vh = Ae, gh = ge, mh = vh(gh, "DataView"), bh = mh, yh = Ae, Th = ge, wh = yh(Th, "Promise"), xh = wh, Sh = Ae, Oh = ge, Ch = Sh(Oh, "Set"), Eh = Ch, _h = Ae, Ph = ge, Ih = _h(Ph, "WeakMap"), Mh = Ih, mr = bh, br = Pr, yr = xh, Tr = Eh, wr = Mh, ji = zt, Fe = Ii, ei = "[object Map]", Rh = "[object Object]", ti = "[object Promise]", ri = "[object Set]", ni = "[object WeakMap]", ii = "[object DataView]", Dh = Fe(mr), kh = Fe(br), zh = Fe(yr), $h = Fe(Tr), jh = Fe(wr), _e = ji;
(mr && _e(new mr(new ArrayBuffer(1))) != ii || br && _e(new br()) != ei || yr && _e(yr.resolve()) != ti || Tr && _e(new Tr()) != ri || wr && _e(new wr()) != ni) && (_e = function(a) {
  var i = ji(a), s = i == Rh ? a.constructor : void 0, u = s ? Fe(s) : "";
  if (u)
    switch (u) {
      case Dh:
        return ii;
      case kh:
        return ei;
      case zh:
        return ti;
      case $h:
        return ri;
      case jh:
        return ni;
    }
  return i;
});
var Ah = _e, gr = vc, Lh = Ri, Hh = su, Wh = fh, oi = Ah, si = Ir, ai = ki, Fh = $i, Uh = 1, li = "[object Arguments]", ci = "[object Array]", yt = "[object Object]", Nh = Object.prototype, ui = Nh.hasOwnProperty;
function Gh(a, i, s, u, v, f) {
  var m = si(a), y = si(i), S = m ? ci : oi(a), C = y ? ci : oi(i);
  S = S == li ? yt : S, C = C == li ? yt : C;
  var D = S == yt, R = C == yt, T = S == C;
  if (T && ai(a)) {
    if (!ai(i))
      return !1;
    m = !0, D = !1;
  }
  if (T && !D)
    return f || (f = new gr()), m || Fh(a) ? Lh(a, i, s, u, v, f) : Hh(a, i, S, s, u, v, f);
  if (!(s & Uh)) {
    var P = D && ui.call(a, "__wrapped__"), _ = R && ui.call(i, "__wrapped__");
    if (P || _) {
      var O = P ? a.value() : a, k = _ ? i.value() : i;
      return f || (f = new gr()), v(O, k, s, u, f);
    }
  }
  return T ? (f || (f = new gr()), Wh(a, i, s, u, v, f)) : !1;
}
var Yh = Gh, Kh = Yh, pi = At;
function Ai(a, i, s, u, v) {
  return a === i ? !0 : a == null || i == null || !pi(a) && !pi(i) ? a !== a && i !== i : Kh(a, i, s, u, Ai, v);
}
var Xh = Ai, Bh = Xh;
function Vh(a, i) {
  return Bh(a, i);
}
var qh = Vh;
const xr = /* @__PURE__ */ rt(qh);
function Y(a, i) {
  return typeof a.get == "function" ? a.get(i) : a[i];
}
function hi(a) {
  return typeof a.count == "function" ? a.count() : a.length;
}
function tt(a, i) {
  return hi(a) === hi(i) && a.every((s, u) => s === Y(i, u.toString()));
}
function Zh(a, i) {
  const s = {};
  return a.forEach((u) => {
    s[u[i]] = u;
  }), s;
}
function wt() {
}
function Pe(...a) {
  return (i, ...s) => {
    i.preventDefault(), a.forEach((u) => u && u(i, ...s));
  };
}
function Li({ item: a, itemContext: i, getItemProps: s, getResizeProps: u }) {
  const { left: v, right: f } = u(), { key: m, ref: y, ...S } = s(a.itemProps ?? {}), { useResizeHandle: C } = i;
  return Tt(
    "div",
    { ...S, ref: y, key: `${m}-outer` },
    C ? Tt("div", { ...v, key: `${m}-lr` }) : null,
    j("div", { className: "rct-item-content", style: { maxHeight: `${i.dimensions.height}` }, children: i.title }, `${m}-content`),
    C ? Tt("div", { ...f, key: `${m}-rr` }) : null
  );
}
function Mt(a, i, s) {
  return (i - a) / s;
}
function Rt(a, i, s, u) {
  const v = s / (i - a);
  return (u - a) * v;
}
function Mr(a, i, s, u) {
  return (i - a) / s * u + a;
}
function Rr(a, i, s, u, v) {
  let f = ue(a).startOf(s);
  if (u[s] && u[s] > 1) {
    const m = f.get(s);
    f = f.set(s, m - m % u[s]);
  }
  for (; f.valueOf() < i; ) {
    let m = ue(f).add(u[s] || 1, s).startOf(s);
    m.valueOf() <= f.valueOf() && (m = m.add(u[s] || 1, s)), v(f, m), f = m;
  }
}
const Sr = 17;
function xt(a, i, s) {
  const u = {
    second: 1e3,
    minute: 60,
    hour: 60,
    day: 24,
    month: 30,
    year: 12
  };
  let v = "year", f = a;
  return Object.keys(u).some((m) => {
    const y = m;
    f = f / u[y];
    const S = f / s[y], C = s[y] && s[y] > 1 ? 3 * Sr : Sr, D = i / C;
    if (S < D)
      return v = m, !0;
  }), v;
}
const Or = {
  second: "minute",
  minute: "hour",
  hour: "day",
  day: "month",
  month: "year",
  year: "year"
};
function Dr(a) {
  if (!Or[a])
    throw new Error(`unit ${a} is not acceptable`);
  return Or[a];
}
function Hi({ itemTimeStart: a, itemTimeEnd: i, dragTime: s, isDragging: u, isResizing: v, resizingEdge: f, resizeTime: m }) {
  const y = i - a;
  return [
    u && s ? s : v && f === "left" && m ? m : a,
    u && s ? s + y : v && f === "right" && m ? m : i
  ];
}
function Wi({ itemTimeStart: a, itemTimeEnd: i, canvasTimeStart: s, canvasTimeEnd: u, canvasWidth: v }) {
  const f = i - a, m = Math.max(a, s), y = Math.min(i, u), S = Rt(s, u, v, m), D = Rt(s, u, v, y) - S;
  return {
    left: S,
    width: Math.max(D, 3),
    collisionLeft: a,
    collisionWidth: f
  };
}
function kr(a, i) {
  const { groupIdKey: s } = i, u = {};
  for (let v = 0; v < a.length; v++)
    u[Y(a[v], s)] = {
      index: v,
      group: a[v]
    };
  return u;
}
function Fi(a, i) {
  var v, f;
  const s = {}, u = Object.keys(i);
  for (let m = 0; m < u.length; m++) {
    const y = i[u[m]];
    s[m] = {
      index: y.index,
      group: y.group,
      items: []
    };
  }
  for (let m = 0; m < a.length; m++)
    if (a[m].dimensions !== void 0 && ((v = a[m].dimensions) == null ? void 0 : v.order) !== void 0) {
      const y = s[((f = a[m].dimensions) == null ? void 0 : f.order.index) ?? 0];
      y && y.items.push(a[m]);
    }
  return s;
}
function zr(a, i, s, u) {
  const { itemTimeStartKey: v, itemTimeEndKey: f } = u;
  return a.filter((m) => {
    const y = ue(Y(m, v)).valueOf() <= s, S = ue(Y(m, f)).valueOf() >= i;
    return y && S;
  });
}
const Jh = 1e-3;
function Ui(a, i, s, u = Jh) {
  return a.collisionLeft + u < i.collisionLeft + i.collisionWidth && a.collisionLeft + a.collisionWidth - u > i.collisionLeft && a.top - s + u < i.top + i.height && a.top + a.height + s - u > i.top;
}
function Ni(a, i, s, u, v, f, m) {
  let y = u;
  const S = m ?? (a - i.dimensions.height) / 2;
  if (i.dimensions.stack && i.dimensions.top === null) {
    i.dimensions.top = v + S, y = Math.max(y, a, i.dimensions.height + S * 2);
    do {
      var C = null;
      for (let D = f - 1, R = 0; D >= R; D--) {
        const T = s[D];
        if (T.dimensions.top !== null && T.dimensions.stack && Ui(i.dimensions, T.dimensions, S)) {
          C = T;
          break;
        }
      }
      C != null && (i.dimensions.top = C.dimensions.top + C.dimensions.height + /* backward compatibility where gap between items is 2 */
      S * (m !== void 0 ? 1 : 2), y = Math.max(y, i.dimensions.top + i.dimensions.height + S - v));
    } while (C);
  }
  return {
    groupHeight: y,
    verticalMargin: S,
    itemTop: i.dimensions.top
  };
}
function Gi(a, i, s, u, v) {
  var m, y;
  const f = v ?? (a - (((m = i.dimensions) == null ? void 0 : m.height) ?? 1)) / 2;
  return i.dimensions && i.dimensions.top === null && (i.dimensions.top = u + f, s = Math.max(s, a, i.dimensions.height + f)), { groupHeight: s, verticalMargin: 0, itemTop: ((y = i.dimensions) == null ? void 0 : y.top) ?? 0 };
}
function di(a = []) {
  return a.reduce((i, s) => i + s, 0);
}
function Yi(a, i, s, u, v) {
  const f = [], m = [], y = Fi(a, i);
  for (const S in y) {
    const C = y[S], { items: D, group: R } = C, T = di(f), P = R.stackItems !== void 0 ? R.stackItems : u, { groupHeight: _ } = Ki(D, P, s, T, v);
    m.push(T), R.height ? f.push(R.height) : f.push(Math.max(_, s));
  }
  return {
    height: di(f),
    groupHeights: f,
    groupTops: m
  };
}
function Ki(a, i, s, u, v) {
  let f = 0, m = 0;
  for (let y = 0; y < a.length; y++) {
    const S = i ? Ni(s, a[y], a, f, u, y, v) : Gi(s, a[y], f, u, v);
    f = S.groupHeight, m = S.verticalMargin;
  }
  return { groupHeight: f, verticalMargin: m };
}
function $e(a, i, s, u, v, f, m, y, S, C, D, R, T, P, _, O) {
  const L = zr(a, u, v, f).map((w) => Bi({
    item: w,
    keys: f,
    draggingItem: C,
    resizingItem: D,
    dragTime: R,
    resizingEdge: T,
    resizeTime: P,
    groups: i,
    newGroupOrder: _
  }));
  if (i.length === 0)
    return {
      dimensionItems: [],
      height: 0,
      groupHeights: [],
      groupTops: []
    };
  const H = kr(i, f), X = L.map((w) => Xi({
    item: w,
    keys: f,
    canvasTimeStart: u,
    canvasTimeEnd: v,
    canvasWidth: s,
    groupOrders: H,
    lineHeight: m,
    itemHeightRatio: y,
    itemVerticalGap: O
  })).filter((w) => !!w), { height: B, groupHeights: V, groupTops: le } = Yi(X, H, m, S, O);
  return { dimensionItems: X, height: B, groupHeights: V, groupTops: le };
}
function ve(a, i) {
  return a * i;
}
function Xi({ item: a, keys: i, canvasTimeStart: s, canvasTimeEnd: u, canvasWidth: v, groupOrders: f, lineHeight: m, itemHeightRatio: y, itemVerticalGap: S }) {
  const C = Y(a, i.itemIdKey), D = Wi({
    itemTimeStart: Y(a, i.itemTimeStartKey),
    itemTimeEnd: Y(a, i.itemTimeEndKey),
    canvasTimeStart: s,
    canvasTimeEnd: u,
    canvasWidth: v
  });
  if (D)
    return D.top = null, D.order = f[Y(a, i.itemGroupKey)], D.stack = !a.isOverlay, D.height = (a.height || m) * (typeof S > "u" ? y : 1), {
      id: C,
      dimensions: D
    };
}
function Bi({ item: a, keys: i, draggingItem: s, resizingItem: u, dragTime: v, resizingEdge: f, resizeTime: m, groups: y, newGroupOrder: S }) {
  if (!u && !s)
    return a;
  const C = Y(a, i.itemIdKey), D = C === s, R = C === u, [T, P] = Hi({
    itemTimeStart: Y(a, i.itemTimeStartKey),
    itemTimeEnd: Y(a, i.itemTimeEndKey),
    isDragging: D,
    isResizing: R,
    dragTime: v,
    resizingEdge: f,
    resizeTime: m
  });
  return {
    ...a,
    [i.itemTimeStartKey]: T,
    [i.itemTimeEndKey]: P,
    [i.itemGroupKey]: D ? Y(y[S], i.groupIdKey) : Y(a, i.itemGroupKey)
  };
}
function $r(a, i, s) {
  const u = i - a, v = a - u * (s - 1) / 2, f = v + u * s;
  return [v, f];
}
function Cr(a, i, s, u, v, f, m) {
  const y = f.buffer, S = m.canvasTimeStart, C = m.canvasTimeEnd, D = m.visibleTimeEnd - m.visibleTimeStart, R = i - a, T = {
    ...m,
    visibleTimeStart: a,
    visibleTimeEnd: i
  }, P = D * (y - 1) * 0.25;
  if (R !== D || a <= S + P || i >= C - P || s) {
    const [O, k] = $r(a, i, y);
    T.canvasTimeStart = O, T.canvasTimeEnd = k;
    const L = {
      ...m,
      ...T
    }, H = ve(L.width, f.buffer);
    Object.assign(T, $e(u, v, H, L.canvasTimeStart, L.canvasTimeEnd, f.keys, f.lineHeight, f.itemHeightRatio, f.stackItems, L.draggingItem, L.resizingItem, L.dragTime, L.resizingEdge, L.resizeTime, L.newGroupOrder, f.itemVerticalGap));
  }
  return T;
}
const mf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NEXT_UNITS: Or,
  calculateDimensions: Wi,
  calculateInteractionNewTimes: Hi,
  calculateScrollCanvas: Cr,
  calculateTimeForXPosition: Mr,
  calculateXPositionForTime: Rt,
  collision: Ui,
  coordinateToTimeRatio: Mt,
  getCanvasBoundariesFromVisibleTime: $r,
  getCanvasWidth: ve,
  getGroupOrders: kr,
  getGroupedItems: Fi,
  getItemDimensions: Xi,
  getItemWithInteractions: Bi,
  getMinUnit: xt,
  getNextUnit: Dr,
  getVisibleItems: zr,
  groupNoStack: Gi,
  groupStack: Ni,
  iterateTimes: Rr,
  minCellWidth: Sr,
  stackAll: Yi,
  stackGroup: Ki,
  stackTimelineItems: $e
}, Symbol.toStringTag, { value: "Module" })), Qh = {
  fontSize: 12,
  color: "white",
  cursor: "pointer",
  background: "#2196f3",
  borderTopWidth: "1px",
  borderBottomWidth: "1px",
  borderLeftWidth: "1px",
  borderRightWidth: "1px",
  borderStyle: "solid",
  borderColor: "#1a6fb3",
  zIndex: 80
}, ed = {
  background: "#ffc107",
  borderTopWidth: "1px",
  borderLeftWidth: "1px",
  borderRightWidth: "1px",
  borderBottomWidth: "1px",
  borderStyle: "solid",
  borderColor: "#ff9800",
  zIndex: 82
}, td = {
  willChange: "left, top, width",
  cursor: "move"
}, rd = {
  borderLeftWidth: 3
}, nd = {
  cursor: "w-resize"
}, id = {
  borderRightWidth: "3px"
}, od = {
  cursor: "e-resize"
}, sd = {
  position: "absolute",
  width: 24,
  maxWidth: "20%",
  minWidth: 2,
  height: "100%",
  top: 0,
  left: 0,
  cursor: "pointer",
  zIndex: 88
}, ad = {
  position: "absolute",
  width: 24,
  maxWidth: "20%",
  minWidth: 2,
  height: "100%",
  top: 0,
  right: 0,
  cursor: "pointer",
  zIndex: 88
}, ld = {
  getTimelineState: () => (console.warn('"getTimelineState" default func is being used'), {}),
  getLeftOffsetFromDate: () => (console.warn('"getLeftOffsetFromDate" default func is being used'), 0),
  getDateFromLeftOffsetPosition: () => (console.warn('"getDateFromLeftOffsetPosition" default func is being used'), 0),
  showPeriod: () => {
    console.warn('"showPeriod" default func is being used');
  }
}, jr = Z.createContext(ld), { Consumer: cd, Provider: ud } = jr;
class pd extends Z.Component {
  constructor(i) {
    super(i), Object.defineProperty(this, "getTimelineState", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { visibleTimeStart: s, visibleTimeEnd: u, canvasTimeStart: v, canvasTimeEnd: f, canvasWidth: m, timelineUnit: y, timelineWidth: S } = this.props;
        return {
          visibleTimeStart: s,
          visibleTimeEnd: u,
          canvasTimeStart: v,
          canvasTimeEnd: f,
          canvasWidth: m,
          timelineUnit: y,
          timelineWidth: S
        };
      }
    }), Object.defineProperty(this, "getLeftOffsetFromDate", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        const { canvasTimeStart: u, canvasTimeEnd: v, canvasWidth: f } = this.props;
        return Rt(u, v, f, s);
      }
    }), Object.defineProperty(this, "getDateFromLeftOffsetPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        const { canvasTimeStart: u, canvasTimeEnd: v, canvasWidth: f } = this.props;
        return Mr(u, v, f, s);
      }
    }), this.state = {
      timelineContext: {
        getTimelineState: this.getTimelineState,
        getLeftOffsetFromDate: this.getLeftOffsetFromDate,
        getDateFromLeftOffsetPosition: this.getDateFromLeftOffsetPosition,
        showPeriod: this.props.showPeriod
      }
    };
  }
  render() {
    return j(ud, { value: this.state.timelineContext, children: this.props.children });
  }
}
const Lt = cd, hd = () => wi(jr);
ue.extend(Ss);
class Ar extends ae {
  constructor(i) {
    super(i), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        interactMounted: !1,
        dragging: !1,
        dragStart: null,
        preDragPosition: null,
        dragTime: null,
        dragGroupDelta: null,
        resizing: !1,
        resizeEdge: null,
        resizeStart: null,
        resizeTime: null
      }
    }), Object.defineProperty(this, "itemId", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "itemTitle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ""
    }), Object.defineProperty(this, "itemDivTitle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "itemTimeStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "itemTimeEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "itemRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: xi()
    }), Object.defineProperty(this, "dragLeft", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "dragRight", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "startedClicking", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "startedTouching", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "dragInProgress", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "fireInteractEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        var u;
        if (this.itemRef && this.itemRef.current) {
          const v = new CustomEvent("itemInteraction", {
            bubbles: !0,
            detail: {
              itemInteraction: s
            }
          });
          (u = this.itemRef.current) == null || u.dispatchEvent(v);
        }
      }
    }), Object.defineProperty(this, "onMouseDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.state.interactMounted || (s.preventDefault(), this.startedClicking = !0);
      }
    }), Object.defineProperty(this, "onMouseUp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        !this.state.interactMounted && this.startedClicking && (this.startedClicking = !1, this.actualClick(s, "click"));
      }
    }), Object.defineProperty(this, "onTouchStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.state.interactMounted || (s.preventDefault(), this.startedTouching = !0);
      }
    }), Object.defineProperty(this, "onTouchEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        !this.state.interactMounted && this.startedTouching && (this.startedTouching = !1, this.actualClick(s, "touch"));
      }
    }), Object.defineProperty(this, "handleDoubleClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        s.stopPropagation(), this.props.onItemDoubleClick && this.props.onItemDoubleClick(this.itemId, s);
      }
    }), Object.defineProperty(this, "handleContextMenu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.props.onContextMenu && (s.preventDefault(), s.stopPropagation(), this.props.onContextMenu(this.itemId, s));
      }
    }), Object.defineProperty(this, "getDragLeftRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => this.dragLeft = s
    }), Object.defineProperty(this, "getDragRightRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => this.dragRight = s
    }), Object.defineProperty(this, "getItemProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s = {}) => {
        const u = "rct-item" + (this.props.item.className ? ` ${this.props.item.className}` : "");
        return {
          key: this.itemId,
          ref: this.itemRef,
          title: this.itemDivTitle,
          className: u + ` ${s.className ? s.className : ""}`,
          onMouseDown: Pe(this.onMouseDown, s.onMouseDown),
          onMouseUp: Pe(this.onMouseUp, s.onMouseUp),
          onTouchStart: Pe(this.onTouchStart, s.onTouchStart),
          onTouchEnd: Pe(this.onTouchEnd, s.onTouchEnd),
          onDoubleClick: Pe(this.handleDoubleClick, s.onDoubleClick),
          onContextMenu: Pe(this.handleContextMenu, s.onContextMenu),
          style: Object.assign({}, this.getItemStyle(s))
        };
      }
    }), Object.defineProperty(this, "getResizeProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s = {}) => {
        let u = "rct-item-handler rct-item-handler-left rct-item-handler-resize-left";
        s.leftClassName && (u += ` ${s.leftClassName}`);
        let v = "rct-item-handler rct-item-handler-right rct-item-handler-resize-right";
        return s.rightClassName && (v += ` ${s.rightClassName}`), {
          left: {
            ref: this.getDragLeftRef,
            className: u,
            style: Object.assign({}, sd, s.leftStyle)
          },
          right: {
            ref: this.getDragRightRef,
            className: v,
            style: Object.assign({}, ad, s.rightStyle)
          }
        };
      }
    }), this.cacheDataFromProps(i);
  }
  shouldComponentUpdate(i, s) {
    return !xr(this.props, i) || !xr(this.state, s);
  }
  cacheDataFromProps(i) {
    this.itemId = Y(i.item, i.keys.itemIdKey), this.itemTitle = Y(i.item, i.keys.itemTitleKey), this.itemDivTitle = i.keys.itemDivTitleKey ? Y(i.item, i.keys.itemDivTitleKey) : this.itemTitle, this.itemTimeStart = Y(i.item, i.keys.itemTimeStartKey), this.itemTimeEnd = Y(i.item, i.keys.itemTimeEndKey);
  }
  getTimeRatio() {
    const { canvasTimeStart: i, canvasTimeEnd: s, canvasWidth: u } = this.props;
    return Mt(i, s, u);
  }
  dragTimeSnap(i, s) {
    const { dragSnap: u } = this.props;
    if (u) {
      const v = s ? ue().utcOffset() * 60 * 1e3 : 0;
      return Math.round(i / u) * u - v % u;
    } else
      return i;
  }
  resizeTimeSnap(i) {
    const { dragSnap: s } = this.props;
    if (s) {
      const u = this.itemTimeEnd % s;
      return Math.round((i - u) / s) * s + u;
    } else
      return i;
  }
  dragTime(i) {
    const s = ue(this.itemTimeStart);
    return this.state.dragging ? this.dragTimeSnap(this.timeFor(i) + this.state.dragStart.offset, !0) : s.valueOf();
  }
  timeFor(i) {
    const s = Mt(this.props.canvasTimeStart, this.props.canvasTimeEnd, this.props.canvasWidth), u = Ct(this.props.scrollRef).offsetLeft, v = Ot(this.props.scrollRef);
    return (i.pageX - u + v.scrollLeft) * s + this.props.canvasTimeStart;
  }
  dragGroupDelta(i) {
    const { groupTops: s, order: u } = this.props;
    if (this.state.dragging) {
      if (!this.props.canChangeGroup)
        return 0;
      let v = 0;
      const f = Ct(this.props.scrollRef).offsetTop, m = Ot(this.props.scrollRef);
      for (const y of Object.keys(s)) {
        const S = s[y];
        if (i.pageY - f + m.scrollTop > S)
          v = parseInt(y, 10) - u.index;
        else
          break;
      }
      return this.props.order.index + v < 0 ? 0 - this.props.order.index : v;
    } else
      return 0;
  }
  resizeTimeDelta(i, s) {
    const u = this.itemTimeEnd - this.itemTimeStart, v = this.dragTimeSnap((i.pageX - this.state.resizeStart) * this.getTimeRatio());
    return u + (s === "left" ? -v : v) < (this.props.dragSnap || 1e3) ? s === "left" ? u - (this.props.dragSnap || 1e3) : (this.props.dragSnap || 1e3) - u : v;
  }
  mountInteract() {
    const i = this.props.useResizeHandle ? ".rct-item-handler-resize-left" : !0, s = this.props.useResizeHandle ? ".rct-item-handler-resize-right" : !0;
    dr(this.itemRef.current).resizable({
      edges: {
        left: this.canResizeLeft() && i,
        right: this.canResizeRight() && s,
        top: !1,
        bottom: !1
      },
      enabled: this.props.selected && (this.canResizeLeft() || this.canResizeRight())
    }).draggable({
      enabled: this.props.selected && this.canMove()
    }).styleCursor(!1).on("dragstart", (u) => {
      if (this.props.selected) {
        this.dragInProgress = !0, this.fireInteractEvent(!0);
        const v = this.timeFor(u);
        this.setState({
          dragging: !0,
          dragStart: {
            x: u.pageX,
            y: u.pageY,
            offset: this.itemTimeStart - v
          },
          preDragPosition: { x: u.target.offsetLeft, y: u.target.offsetTop },
          dragTime: this.itemTimeStart,
          dragGroupDelta: 0
        });
      } else
        return !1;
    }).on("dragmove", (u) => {
      this.state.dragging && this.setState((v) => {
        if (!this.dragInProgress)
          return { ...v };
        let f = this.dragTime(u);
        const m = this.dragGroupDelta(u);
        return this.props.moveResizeValidator && (f = this.props.moveResizeValidator("move", this.props.item, f)), this.props.onDrag && this.props.onDrag(this.itemId, f, this.props.order.index + m), {
          dragTime: f,
          dragGroupDelta: m
        };
      });
    }).on("dragend", (u) => {
      if (this.state.dragging) {
        if (this.props.onDrop) {
          this.dragInProgress = !1, this.fireInteractEvent(!1);
          let v = this.dragTime(u);
          this.props.moveResizeValidator && (v = this.props.moveResizeValidator("move", this.props.item, v)), this.props.onDrop(this.itemId, v, this.props.order.index + this.dragGroupDelta(u));
        }
        this.setState({
          dragging: !1,
          dragStart: null,
          preDragPosition: null,
          dragTime: null,
          dragGroupDelta: null
        });
      }
    }).on("resizestart", (u) => {
      if (this.props.selected)
        this.fireInteractEvent(!0), this.setState({
          resizing: !0,
          resizeEdge: null,
          // we don't know yet
          resizeStart: u.pageX,
          resizeTime: 0
        });
      else
        return !1;
    }).on("resizemove", (u) => {
      if (this.state.resizing) {
        let v = this.state.resizeEdge;
        v || (v = u.deltaRect.left !== 0 ? "left" : "right", this.setState({ resizeEdge: v }));
        let f = this.resizeTimeSnap(this.timeFor(u));
        this.props.moveResizeValidator && (f = this.props.moveResizeValidator("resize", this.props.item, f, v)), this.props.onResizing && this.props.onResizing(this.itemId, f, v), this.setState({
          resizeTime: f
        });
      }
    }).on("resizeend", (u) => {
      if (this.state.resizing) {
        this.fireInteractEvent(!1);
        const { resizeEdge: v } = this.state;
        let f = this.resizeTimeSnap(this.timeFor(u));
        this.props.moveResizeValidator && (f = this.props.moveResizeValidator("resize", this.props.item, f, v)), this.props.onResized && this.props.onResized(this.itemId, f, v, this.resizeTimeDelta(u, v)), this.setState({
          resizing: !1,
          resizeStart: null,
          resizeEdge: null,
          resizeTime: null
        });
      }
    }).on("tap", (u) => {
      this.actualClick(u, u.pointerType === "mouse" ? "click" : "touch");
    }), this.setState({
      interactMounted: !0
    });
  }
  canResizeLeft(i = this.props) {
    var u;
    return !i.canResizeLeft || i.minResizeWidth === void 0 ? !1 : parseInt((u = i.dimensions.width) == null ? void 0 : u.toString(), 10) >= i.minResizeWidth;
  }
  canResizeRight(i = this.props) {
    var u;
    return !i.canResizeRight || i.minResizeWidth === void 0 ? !1 : parseInt((u = i.dimensions.width) == null ? void 0 : u.toString(), 10) >= i.minResizeWidth;
  }
  canMove(i = this.props) {
    return !!i.canMove;
  }
  componentDidUpdate(i) {
    this.cacheDataFromProps(this.props);
    let { interactMounted: s } = this.state;
    const u = i.selected && this.canMove(i), v = i.selected && this.canResizeLeft(i), f = i.selected && this.canResizeRight(i), m = this.props.selected && this.canMove(this.props), y = this.props.selected && this.canResizeLeft(this.props), S = this.props.selected && this.canResizeRight(this.props);
    if (this.itemRef && this.itemRef.current) {
      if (this.props.selected && !s && (this.mountInteract(), s = !0), s && (v !== y || f !== S)) {
        const C = this.props.useResizeHandle ? this.dragLeft : !0, D = this.props.useResizeHandle ? this.dragRight : !0;
        dr(this.itemRef.current).resizable({
          enabled: y || S,
          edges: {
            top: !1,
            bottom: !1,
            left: y && C,
            right: S && D
          }
        });
      }
      s && u !== m && dr(this.itemRef.current).draggable({ enabled: m });
    } else
      s = !1;
    s !== this.state.interactMounted && this.setState({
      interactMounted: s
    });
  }
  actualClick(i, s) {
    this.props.canSelect && this.props.onSelect && this.props.onSelect(this.itemId, s, i);
  }
  getItemStyle(i) {
    const s = this.props.dimensions, u = {
      position: "absolute",
      boxSizing: "border-box",
      left: `${s.left}px`,
      top: `${s.top}px`,
      width: `${s.width}px`,
      height: `${s.height}px`,
      lineHeight: `${s.height}px`
    };
    return Object.assign({}, Qh, this.props.selected ? ed : {}, this.props.selected && this.canMove(this.props) ? td : {}, this.props.selected && this.canResizeLeft(this.props) ? rd : {}, this.props.selected && this.canResizeLeft(this.props) && this.state.dragging ? nd : {}, this.props.selected && this.canResizeRight(this.props) ? id : {}, this.props.selected && this.canResizeRight(this.props) && this.state.dragging ? od : {}, i.style, u);
  }
  render() {
    if (typeof this.props.order > "u" || this.props.order === null)
      return null;
    const i = this.context, s = {
      dimensions: this.props.dimensions,
      useResizeHandle: !!this.props.useResizeHandle,
      title: this.itemTitle,
      canMove: this.canMove(this.props),
      canResizeLeft: this.canResizeLeft(this.props),
      canResizeRight: this.canResizeRight(this.props),
      selected: this.props.selected,
      dragging: this.state.dragging,
      dragStart: this.state.dragStart,
      dragTime: this.state.dragTime,
      dragGroupDelta: this.state.dragGroupDelta,
      resizing: this.state.resizing,
      resizeEdge: this.state.resizeEdge,
      resizeStart: this.state.resizeStart,
      resizeTime: this.state.resizeTime
    };
    return this.props.itemRenderer ? this.props.itemRenderer({
      item: this.props.item,
      timelineContext: i,
      itemContext: s,
      getItemProps: this.getItemProps,
      getResizeProps: this.getResizeProps
    }) : Li({
      item: this.props.item,
      itemContext: s,
      getItemProps: this.getItemProps,
      getResizeProps: this.getResizeProps
    });
  }
}
Object.defineProperty(Ar, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    selected: !1,
    itemRenderer: Li
  }
});
Object.defineProperty(Ar, "contextType", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: jr
});
function dd(a, i) {
  const s = Y(a, "canResize") !== void 0 ? Y(a, "canResize") : i;
  return s === "left" || s === "both";
}
function fd(a, i) {
  const s = Y(a, "canResize") !== void 0 ? Y(a, "canResize") : i;
  return s === "right" || s === "both" || s === !0;
}
class vd extends ae {
  shouldComponentUpdate(i) {
    return !(tt(i.groups, this.props.groups) && tt(i.items, this.props.items) && tt(i.dimensionItems, this.props.dimensionItems) && i.keys === this.props.keys && i.canvasTimeStart === this.props.canvasTimeStart && i.canvasTimeEnd === this.props.canvasTimeEnd && i.canvasWidth === this.props.canvasWidth && i.selectedItem === this.props.selectedItem && i.selected === this.props.selected && i.dragSnap === this.props.dragSnap && i.minResizeWidth === this.props.minResizeWidth && i.canChangeGroup === this.props.canChangeGroup && i.canMove === this.props.canMove && i.canResize === this.props.canResize && i.canSelect === this.props.canSelect);
  }
  isSelected(i, s) {
    if (this.props.selected) {
      const u = Y(i, s);
      return this.props.selected.includes(u);
    } else
      return this.props.selectedItem === Y(i, s);
  }
  getVisibleItems(i, s) {
    const { keys: u, items: v } = this.props;
    return zr(v, i, s, u);
  }
  render() {
    const { canvasTimeStart: i, canvasTimeEnd: s, dimensionItems: u, keys: v, groups: f } = this.props, { itemIdKey: m, itemGroupKey: y } = v, S = kr(f, v), C = this.getVisibleItems(i, s), D = Zh(u, "id");
    return j("div", { className: "rct-items", children: C.filter((R) => D[Y(R, m)]).map((R) => j(Ar, { itemProps: R.itemProps, item: R, keys: this.props.keys, order: S[Y(R, y)], dimensions: D[Y(R, m)].dimensions, selected: this.isSelected(R, m), canChangeGroup: Y(R, "canChangeGroup") !== void 0 ? Y(R, "canChangeGroup") : this.props.canChangeGroup, canMove: Y(R, "canMove") !== void 0 ? Y(R, "canMove") : this.props.canMove, canResizeLeft: dd(R, this.props.canResize), canResizeRight: fd(R, this.props.canResize), canSelect: Y(R, "canSelect") !== void 0 ? Y(R, "canSelect") : this.props.canSelect, useResizeHandle: this.props.useResizeHandle, groupTops: this.props.groupTops, canvasTimeStart: this.props.canvasTimeStart, canvasTimeEnd: this.props.canvasTimeEnd, canvasWidth: this.props.canvasWidth, dragSnap: this.props.dragSnap, minResizeWidth: this.props.minResizeWidth, onResizing: this.props.itemResizing, onResized: this.props.itemResized, moveResizeValidator: this.props.moveResizeValidator, onDrag: this.props.itemDrag, onDrop: this.props.itemDrop, onItemDoubleClick: this.props.onItemDoubleClick, onContextMenu: this.props.onItemContextMenu, onSelect: this.props.itemSelect, itemRenderer: this.props.itemRenderer, scrollRef: this.props.scrollRef }, Y(R, m))) });
  }
}
class fi extends ae {
  shouldComponentUpdate(i) {
    return !(i.keys === this.props.keys && i.width === this.props.width && i.height === this.props.height && tt(i.groups, this.props.groups) && tt(i.groupHeights, this.props.groupHeights));
  }
  renderGroupContent(i, s = !1, u, v) {
    return this.props.groupRenderer ? Z.createElement(this.props.groupRenderer, {
      group: i,
      isRightSidebar: s
    }) : Y(i, s ? v : u);
  }
  render() {
    const { width: i, groupHeights: s, height: u, isRightSidebar: v } = this.props, { groupIdKey: f, groupTitleKey: m, groupRightTitleKey: y } = this.props.keys, S = {
      width: `${i}px`,
      height: `${u}px`
    }, C = {
      width: `${i}px`
    }, D = this.props.groups.map((R, T) => {
      const P = {
        height: `${s[T]}px`,
        lineHeight: `${s[T]}px`
      };
      return j("div", { className: "rct-sidebar-row rct-sidebar-row-" + (T % 2 === 0 ? "even" : "odd"), style: P, children: this.renderGroupContent(R, v, m, y) }, Y(R, f));
    });
    return j("div", { className: "rct-sidebar" + (v ? " rct-sidebar-right" : ""), style: S, children: j("div", { style: C, children: D }) });
  }
}
class gd extends ae {
  shouldComponentUpdate(i) {
    return !(i.canvasTimeStart === this.props.canvasTimeStart && i.canvasTimeEnd === this.props.canvasTimeEnd && i.canvasWidth === this.props.canvasWidth && i.lineCount === this.props.lineCount && i.minUnit === this.props.minUnit && i.timeSteps === this.props.timeSteps && i.height === this.props.height && i.verticalLineClassNamesForTime === this.props.verticalLineClassNamesForTime);
  }
  render() {
    const {
      canvasTimeStart: i,
      canvasTimeEnd: s,
      // canvasWidth,
      minUnit: u,
      timeSteps: v,
      height: f,
      verticalLineClassNamesForTime: m,
      getLeftOffsetFromDate: y
    } = this.props, S = [];
    return Rr(i, s, u, v, (C, D) => {
      const T = C.get(u === "day" ? "date" : u) === (u === "day" ? 1 : 0);
      let P = [];
      m && (P = m(
        C.unix() * 1e3,
        // turn into ms, which is what verticalLineClassNamesForTime expects
        D.unix() * 1e3 - 1
      ));
      const _ = "rct-vl" + (T ? " rct-vl-first" : "") + (u === "day" || u === "hour" || u === "minute" ? ` rct-day-${C.day()} ` : " ") + P.join(" "), O = y(C.valueOf()), k = y(D.valueOf());
      S.push(j("div", { className: _, style: {
        pointerEvents: "none",
        top: "0px",
        left: `${O}px`,
        width: `${k - O}px`,
        height: `${f}px`
      } }, `line-${C.valueOf()}`));
    }), j("div", { className: "rct-vertical-lines", children: S });
  }
}
const md = ({ ...a }) => j(Lt, { children: ({ getLeftOffsetFromDate: i }) => j(gd, { getLeftOffsetFromDate: i, ...a }) });
class bd extends ae {
  constructor() {
    super(...arguments), Object.defineProperty(this, "handleMouseDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.originClickX = i.clientX;
      }
    }), Object.defineProperty(this, "handleMouseUp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.props.clickTolerance !== void 0 && Math.abs(this.originClickX - i.clientX) > this.props.clickTolerance && (this.cancelClick = !0);
      }
    }), Object.defineProperty(this, "handleClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        this.cancelClick || this.props.onClick(i), this.cancelClick = !1, this.originClickX = null;
      }
    }), Object.defineProperty(this, "originClickX", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "cancelClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    });
  }
  render() {
    const i = Z.Children.only(this.props.children);
    return Z.cloneElement(i, {
      onMouseDown: this.handleMouseDown,
      onMouseUp: this.handleMouseUp,
      onClick: this.handleClick
    });
  }
}
class yd extends ae {
  render() {
    const { onContextMenu: i, onDoubleClick: s, isEvenRow: u, style: v, onClick: f, clickTolerance: m, horizontalLineClassNamesForGroup: y, group: S } = this.props;
    let C = [];
    return y && (C = y(S)), j(bd, { clickTolerance: m, onClick: f, children: j("div", { onContextMenu: i, onDoubleClick: s, className: (u ? "rct-hl-even " : "rct-hl-odd ") + (C ? C.join(" ") : ""), style: v }) });
  }
}
class Td extends ae {
  shouldComponentUpdate(i) {
    return !(i.canvasWidth === this.props.canvasWidth && i.lineCount === this.props.lineCount && i.groupHeights === this.props.groupHeights && i.groups === this.props.groups);
  }
  render() {
    const { canvasWidth: i, lineCount: s, groupHeights: u, onRowClick: v, onRowDoubleClick: f, clickTolerance: m, groups: y, horizontalLineClassNamesForGroup: S, onRowContextClick: C } = this.props, D = [];
    for (let R = 0; R < s; R++)
      D.push(j(yd, { clickTolerance: m, onContextMenu: (T) => C(T, R), onClick: (T) => v(T, R), onDoubleClick: (T) => f(T, R), isEvenRow: R % 2 === 0, group: y[R], horizontalLineClassNamesForGroup: S, style: {
        width: `${i}px`,
        height: `${u[R]}px`
      } }, `horizontal-line-${R}`));
    return j("div", { className: "rct-horizontal-lines", children: D });
  }
}
class wd extends ae {
  constructor(i) {
    super(i), Object.defineProperty(this, "scrollComponentRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: xi()
    }), Object.defineProperty(this, "dragLastPosition", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "lastTouchDistance", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "singleTouchStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "lastSingleTouch", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "isItemInteraction", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: !1
    }), Object.defineProperty(this, "handlePointerStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        s.pointerType === "touch" ? this.handleTouchStart(s) : s.pointerType === "mouse" && this.handleMouseDown(s);
      }
    }), Object.defineProperty(this, "handlePointerMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        s.pointerType === "touch" ? this.handleTouchMove(s) : s.pointerType === "mouse" && this.handleMouseMove(s);
      }
    }), Object.defineProperty(this, "handlePointerEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        s.pointerType === "touch" ? this.handleTouchEnd() : s.pointerType === "mouse" && this.handleMouseUp();
      }
    }), Object.defineProperty(this, "handleScroll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const s = this.scrollComponentRef.current.scrollLeft;
        this.props.onScroll(s);
      }
    }), Object.defineProperty(this, "handleWheel", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        if (s.ctrlKey || s.metaKey || s.altKey) {
          s.preventDefault();
          const u = Hn(s.currentTarget), v = s.clientX - u.x, f = s.ctrlKey ? 10 : s.metaKey ? 3 : 1;
          this.props.onWheelZoom(f, v, s.deltaY);
        } else s.shiftKey && (s.preventDefault(), this.props.onScroll(this.scrollComponentRef.current.scrollLeft + (s.deltaY || s.deltaX)));
      }
    }), Object.defineProperty(this, "handleMouseDown", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        s.button === 0 && (this.dragLastPosition = s.pageX, this.setState({
          isDragging: !0
        }));
      }
    }), Object.defineProperty(this, "handleMouseMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.state.isDragging && !this.isItemInteraction && (this.props.onScroll(this.scrollComponentRef.current.scrollLeft + this.dragLastPosition - s.pageX), this.dragLastPosition = s.pageX);
      }
    }), Object.defineProperty(this, "handleMouseUp", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.dragLastPosition = null, this.setState({
          isDragging: !1
        });
      }
    }), Object.defineProperty(this, "handlePointerLeave", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        s.pointerType === "mouse" && (this.dragLastPosition = null, this.setState({
          isDragging: !1
        }));
      }
    }), Object.defineProperty(this, "handleTouchStart", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        s.isPrimary ? (s.preventDefault(), this.lastTouchDistance = null, this.singleTouchStart = { x: s.clientX, y: s.clientY, screenY: window.scrollY }, this.lastSingleTouch = { x: s.clientX, y: s.clientY, screenY: window.scrollY }) : (s.preventDefault(), this.lastTouchDistance = Math.abs(s.clientX - this.singleTouchStart.x), this.singleTouchStart = null, this.lastSingleTouch = null);
      }
    }), Object.defineProperty(this, "handleTouchMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        const { width: u, onZoom: v } = this.props;
        if (this.isItemInteraction) {
          s.preventDefault();
          return;
        }
        if (this.lastTouchDistance && !s.isPrimary) {
          s.preventDefault();
          const f = Math.abs(s.clientX - this.singleTouchStart.x), m = Hn(s.currentTarget), y = (s.clientX + this.singleTouchStart.x) / 2 - m.x;
          f !== 0 && this.lastTouchDistance !== 0 && (v(this.lastTouchDistance / f, y / u), this.lastTouchDistance = f);
        } else if (this.lastSingleTouch && s.isPrimary) {
          s.preventDefault();
          const f = s.clientX, m = s.clientY, y = f - this.lastSingleTouch.x, S = f - this.singleTouchStart.x, C = m - this.singleTouchStart.y;
          this.lastSingleTouch = { x: f, y: m, screenY: window.pageYOffset };
          const D = Math.abs(S) * 3 > Math.abs(C), R = Math.abs(C) * 3 > Math.abs(S);
          y !== 0 && D && this.props.onScroll(this.scrollComponentRef.current.scrollLeft - y), R && window.scrollTo(window.scrollX, this.singleTouchStart.screenY - C);
        }
      }
    }), Object.defineProperty(this, "handleTouchEnd", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.lastTouchDistance && (this.lastTouchDistance = null), this.lastSingleTouch && (this.lastSingleTouch = null, this.singleTouchStart = null);
      }
    }), Object.defineProperty(this, "handleItemInteract", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        this.isItemInteraction = s.detail.itemInteraction;
      }
    }), this.state = {
      isDragging: !1
    };
  }
  componentDidMount() {
    this.scrollComponentRef.current && (this.props.scrollRef(this.scrollComponentRef.current), this.scrollComponentRef.current.addEventListener("wheel", this.handleWheel, { passive: !1 }), this.scrollComponentRef.current.addEventListener("itemInteraction", this.handleItemInteract), this.scrollComponentRef.current.addEventListener("pointerdown", this.handlePointerStart, { passive: !1 }), this.scrollComponentRef.current.addEventListener("pointermove", this.handlePointerMove, { passive: !1 }), this.scrollComponentRef.current.addEventListener("pointerup", this.handlePointerEnd), this.scrollComponentRef.current.addEventListener("pointerleave", this.handlePointerLeave));
  }
  componentWillUnmount() {
    this.scrollComponentRef.current && (this.scrollComponentRef.current.removeEventListener("wheel", this.handleWheel), this.scrollComponentRef.current.removeEventListener("itemInteraction", this.handleItemInteract), this.scrollComponentRef.current.removeEventListener("pointerdown", this.handlePointerStart), this.scrollComponentRef.current.removeEventListener("pointermove", this.handlePointerMove), this.scrollComponentRef.current.removeEventListener("pointerup", this.handlePointerEnd), this.scrollComponentRef.current.removeEventListener("pointerleave", this.handlePointerLeave));
  }
  render() {
    const { width: i, height: s, children: u } = this.props, { isDragging: v } = this.state, f = {
      width: `${i}px`,
      height: `${s + 20}px`,
      //20px to push the scroll element down off screen...?
      cursor: v ? "move" : "default",
      position: "relative"
    };
    return j("div", { ref: this.scrollComponentRef, "data-testid": "scroll-element", className: "rct-scroll", style: f, onScroll: this.handleScroll, children: u });
  }
}
const xd = {
  subscribeToMouseOver: () => (console.warn('"subscribeToMouseOver" default func is being used'), () => {
  })
}, { Consumer: Sd, Provider: Od } = Z.createContext(xd), Cd = Od, Ed = Sd, _d = {
  markers: [],
  subscribeMarker: () => (console.warn("default subscribe marker used"), {
    unsubscribe: wt,
    getMarker: wt
  }),
  updateMarker: () => (console.warn("default subscribe marker used"), wt)
}, { Consumer: Pd, Provider: Id } = Z.createContext(_d);
let vi = 0;
const Md = () => (vi += 1, vi + 1);
class Rd extends Z.Component {
  constructor(i) {
    super(i), Object.defineProperty(this, "handleSubscribeToMarker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => (s = {
        ...s,
        // REVIEW: in the event that we accept id to be passed to the Marker components, this line would override those
        id: Md()
      }, this.setState((u) => ({
        markers: [...u.markers, s]
      })), {
        unsubscribe: () => {
          this.setState((u) => ({
            markers: u.markers.filter((v) => v.id !== s.id)
          }));
        },
        getMarker: () => s
      })
    }), Object.defineProperty(this, "handleUpdateMarker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (s) => {
        const u = this.state.markers.findIndex((v) => v.id === s.id);
        u < 0 || this.setState((v) => ({
          markers: [
            ...v.markers.slice(0, u),
            s,
            ...v.markers.slice(u + 1)
          ]
        }));
      }
    }), this.state = {
      markers: [],
      subscribeMarker: this.handleSubscribeToMarker,
      updateMarker: this.handleUpdateMarker
    };
  }
  render() {
    return j(Id, { value: this.state, children: this.props.children });
  }
}
const Ht = Pd;
var xe;
(function(a) {
  a.Today = "Today", a.Custom = "Custom", a.Cursor = "Cursor";
})(xe || (xe = {}));
const Dd = {
  position: "absolute",
  top: 0,
  bottom: 0,
  width: "2px",
  backgroundColor: "black",
  // by default, pointer events (specifically click) will
  // "pass through".  This is added so that CursorMarker
  // will not get in the way of canvas click
  pointerEvents: "none"
}, Lr = (a) => ({
  ...Dd,
  left: a
}), Hr = (a) => function({ styles: s }) {
  return j("div", { style: s, "data-testid": a });
}, kd = Hr("default-today-line");
let Vi = class extends Z.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        date: Date.now()
      }
    }), Object.defineProperty(this, "intervalToken", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    });
  }
  componentDidMount() {
    this.intervalToken = this.createIntervalUpdater(this.props.interval);
  }
  componentDidUpdate(i) {
    i.interval !== this.props.interval && (clearInterval(this.intervalToken), this.intervalToken = this.createIntervalUpdater(this.props.interval));
  }
  createIntervalUpdater(i) {
    return setInterval(() => {
      this.setState({
        date: Date.now()
        // FIXME: use date utils pass in as props
      });
    }, i);
  }
  componentWillUnmount() {
    clearInterval(this.intervalToken);
  }
  render() {
    const { date: i } = this.state, s = this.props.getLeftOffsetFromDate(i), u = Lr(s);
    return this.props.renderer({ styles: u, date: i });
  }
};
Object.defineProperty(Vi, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    renderer: kd
  }
});
const zd = Hr("default-customer-marker-id");
let qi = class extends Z.Component {
  render() {
    const { date: i } = this.props, s = this.props.getLeftOffsetFromDate(i), u = Lr(s);
    return this.props.renderer({ styles: u, date: i });
  }
};
Object.defineProperty(qi, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    renderer: zd
  }
});
const $d = Hr("default-cursor-marker");
let Zi = class extends Z.Component {
  constructor(i) {
    super(i), Object.defineProperty(this, "handleCanvasMouseOver", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ({ leftOffset: s, date: u, isCursorOverCanvas: v }) => {
        this.setState({
          leftOffset: s,
          date: u,
          isShowingCursor: v
        });
      }
    }), Object.defineProperty(this, "unsubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.state = {
      leftOffset: 0,
      date: 0,
      isShowingCursor: !1
    };
  }
  componentDidMount() {
    this.unsubscribe = this.props.subscribeToCanvasMouseOver(this.handleCanvasMouseOver);
  }
  componentWillUnmount() {
    this.unsubscribe && (this.unsubscribe(), this.unsubscribe = void 0);
  }
  render() {
    const { isShowingCursor: i, leftOffset: s, date: u } = this.state;
    if (!i)
      return null;
    const v = Lr(s);
    return this.props.renderer ? this.props.renderer({ styles: v, date: u }) : null;
  }
};
Object.defineProperty(Zi, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    renderer: $d
  }
});
const Ji = (a) => j(Ed, { children: ({ subscribeToMouseOver: i }) => j(Zi, { subscribeToCanvasMouseOver: i, ...a }) });
Ji.displayName = "CursorMarkerWrapper";
const jd = () => j(Lt, { children: ({ getLeftOffsetFromDate: a, getTimelineState: i }) => j(Ht, { children: ({ markers: s }) => {
  const u = i();
  return s.map((v) => {
    switch (v.type) {
      case xe.Today:
        return (/* @__PURE__ */ new Date()).valueOf() >= u.canvasTimeStart && (/* @__PURE__ */ new Date()).valueOf() <= u.canvasTimeEnd ? j(Vi, { getLeftOffsetFromDate: a, renderer: v.renderer, interval: v.interval }, v.id) : null;
      case xe.Custom:
        return v.date >= u.canvasTimeStart && v.date <= u.canvasTimeEnd ? j(qi, { renderer: v.renderer, date: v.date, getLeftOffsetFromDate: a }, v.id) : null;
      case xe.Cursor:
        return j(Ji, { renderer: v.renderer, getLeftOffsetFromDate: a }, v.id);
      default:
        return null;
    }
  });
} }) }), Ad = {
  position: "absolute",
  left: 0,
  right: 0,
  top: 0,
  bottom: 0
};
class Ld extends Z.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "handleMouseMove", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => {
        var s;
        if (this.subscription !== null) {
          const { pageX: u } = i, { left: v } = ((s = this.containerEl.current) == null ? void 0 : s.getBoundingClientRect()) ?? {
            left: 0
          }, f = u - v, m = this.props.getDateFromLeftOffsetPosition(f);
          this.subscription({
            leftOffset: f,
            date: m,
            isCursorOverCanvas: !0
          });
        }
      }
    }), Object.defineProperty(this, "handleMouseLeave", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        this.subscription !== null && this.subscription({ leftOffset: 0, date: 0, isCursorOverCanvas: !1 });
      }
    }), Object.defineProperty(this, "handleMouseMoveSubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => (this.subscription = i, () => {
        this.subscription = null;
      })
    }), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: {
        subscribeToMouseOver: this.handleMouseMoveSubscribe
      }
    }), Object.defineProperty(this, "containerEl", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z.createRef()
    }), Object.defineProperty(this, "subscription", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  render() {
    return j(Cd, { value: this.state, children: ze("div", { style: Ad, onMouseMove: this.handleMouseMove, onMouseLeave: this.handleMouseLeave, ref: this.containerEl, children: [j(jd, {}), this.props.children] }) });
  }
}
const Hd = (a) => j(Lt, { children: ({ getDateFromLeftOffsetPosition: i }) => j(Ld, { getDateFromLeftOffsetPosition: i, ...a }) });
function Wd(a) {
  a._resizeEventListener = () => a.resize(), window.addEventListener("resize", a._resizeEventListener);
}
function Fd(a) {
  window.removeEventListener("resize", a._resizeEventListener);
}
const gi = { addListener: Wd, removeListener: Fd }, Ud = {
  groupIdKey: "id",
  groupTitleKey: "title",
  groupRightTitleKey: "rightTitle",
  groupLabelKey: "title",
  itemIdKey: "id",
  itemTitleKey: "title",
  itemDivTitleKey: "title",
  itemGroupKey: "group",
  itemTimeStartKey: "start_time",
  itemTimeEndKey: "end_time"
}, Nd = {
  second: 1,
  minute: 1,
  hour: 1,
  day: 1,
  month: 1,
  year: 1
}, Gd = {
  year: {
    long: "YYYY",
    mediumLong: "YYYY",
    medium: "YYYY",
    short: "YY"
  },
  month: {
    long: "MMMM YYYY",
    mediumLong: "MMMM",
    medium: "MMMM",
    short: "MM/YY"
  },
  week: {
    long: "w",
    mediumLong: "w",
    medium: "w",
    short: "w"
  },
  day: {
    long: "dddd, LL",
    mediumLong: "dddd, LL",
    medium: "dd D",
    short: "D"
  },
  hour: {
    long: "dddd, LL, HH:00",
    mediumLong: "L, HH:00",
    medium: "HH:00",
    short: "HH"
  },
  minute: {
    long: "HH:mm",
    mediumLong: "HH:mm",
    medium: "HH:mm",
    short: "mm"
  },
  second: {
    long: "mm:ss",
    mediumLong: "mm:ss",
    medium: "mm:ss",
    short: "ss"
  }
}, Yd = {
  registerScroll: () => (console.warn("default registerScroll header used"), wt),
  rightSidebarWidth: 0,
  leftSidebarWidth: 150,
  timeSteps: {}
}, Qi = Z.createContext(Yd);
class Kd extends Z.Component {
  render() {
    const i = {
      rightSidebarWidth: this.props.rightSidebarWidth,
      leftSidebarWidth: this.props.leftSidebarWidth,
      timeSteps: this.props.timeSteps,
      registerScroll: this.props.registerScroll
    };
    return j(Qi.Provider, { value: i, children: this.props.children });
  }
}
const Xd = Qi, Wr = () => wi(Xd);
var eo = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(a) {
  (function() {
    var i = {}.hasOwnProperty;
    function s() {
      for (var f = "", m = 0; m < arguments.length; m++) {
        var y = arguments[m];
        y && (f = v(f, u(y)));
      }
      return f;
    }
    function u(f) {
      if (typeof f == "string" || typeof f == "number")
        return f;
      if (typeof f != "object")
        return "";
      if (Array.isArray(f))
        return s.apply(null, f);
      if (f.toString !== Object.prototype.toString && !f.toString.toString().includes("[native code]"))
        return f.toString();
      var m = "";
      for (var y in f)
        i.call(f, y) && f[y] && (m = v(m, y));
      return m;
    }
    function v(f, m) {
      return m ? f ? f + " " + m : f + m : f;
    }
    a.exports ? (s.default = s, a.exports = s) : window.classNames = s;
  })();
})(eo);
var Bd = eo.exports;
const mi = /* @__PURE__ */ rt(Bd), Vd = "left", to = "right";
class qd extends Ts {
  constructor() {
    super(...arguments), Object.defineProperty(this, "getRootProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i = {}) => {
        const { style: s } = i, u = this.props.variant === to ? this.props.rightSidebarWidth : this.props.leftSidebarWidth;
        return {
          style: {
            color: (s == null ? void 0 : s.color) ?? "#fff",
            ...s,
            width: u
          }
        };
      }
    }), Object.defineProperty(this, "getStateAndHelpers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => ({
        getRootProps: this.getRootProps,
        data: this.props.headerData
      })
    });
  }
  render() {
    const i = this.getStateAndHelpers();
    return this.props.children(i);
  }
}
const Zd = ({ getRootProps: a }) => j("div", { "data-testid": "sidebarHeader", ...a() }), St = (a) => {
  const { children: i, variant: s = Vd, headerData: u } = a, { leftSidebarWidth: v, rightSidebarWidth: f } = Wr();
  return j(qd, { leftSidebarWidth: v, rightSidebarWidth: f, variant: s, headerData: u, children: i || Zd });
};
St.secretKey = "SidebarHeader";
class Jd extends Z.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "getRootStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => ({
        ...this.props.style,
        display: "flex",
        width: "100%"
      })
    }), Object.defineProperty(this, "getCalendarHeaderStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { leftSidebarWidth: i, rightSidebarWidth: s, calendarHeaderStyle: u } = this.props;
        return {
          ...u,
          overflow: "hidden",
          width: `calc(100% - ${i + s}px)`
        };
      }
    }), Object.defineProperty(this, "isSidebarHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i) => i.type === void 0 ? !1 : i.type.secretKey === St.secretKey
    });
  }
  render() {
    let i, s;
    const u = [], v = Array.isArray(this.props.children) ? this.props.children.filter((f) => f) : [this.props.children];
    return Z.Children.map(v, (f) => {
      var m;
      this.isSidebarHeader(f) ? ((m = f == null ? void 0 : f.props) == null ? void 0 : m.variant) === to ? i = f : s = f : u.push(f);
    }), s || (s = j(St, {})), !i && this.props.rightSidebarWidth && (i = j(St, { variant: "right" })), ze("div", { "data-testid": "headerRootDiv", style: this.getRootStyle(), className: mi("rct-header-root", this.props.className), children: [s, j("div", { ref: this.props.registerScroll, style: this.getCalendarHeaderStyle(), className: mi("rct-calendar-header", this.props.calendarHeaderClassName), "data-testid": "headerContainer", children: u }), i] });
  }
}
const Er = ({ children: a, style: i, className: s, calendarHeaderStyle: u, calendarHeaderClassName: v }) => {
  const { leftSidebarWidth: f, rightSidebarWidth: m, registerScroll: y } = Wr();
  return j(Jd, { leftSidebarWidth: f, rightSidebarWidth: m, registerScroll: y, style: i, className: s, calendarHeaderStyle: u, calendarHeaderClassName: v, children: a });
};
Er.secretKey = "TimelineHeaders";
class ro extends Z.Component {
  constructor(i) {
    super(i), Object.defineProperty(this, "getHeaderIntervals", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ({ canvasTimeStart: S, canvasTimeEnd: C, unit: D, timeSteps: R, getLeftOffsetFromDate: T }) => {
        const P = [];
        return Rr(S, C, D, R, (_, O) => {
          const k = T(_.valueOf()), H = T(O.valueOf()) - k;
          P.push({
            startTime: _,
            endTime: O,
            labelWidth: H,
            left: k
          });
        }), P;
      }
    }), Object.defineProperty(this, "getRootProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (S = {}) => {
        const { style: C } = S;
        return {
          style: Object.assign({}, C || {}, {
            position: "relative",
            width: this.props.canvasWidth,
            height: this.props.height
          })
        };
      }
    }), Object.defineProperty(this, "getIntervalProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (S = {}) => {
        const { interval: C, style: D } = S;
        if (!C)
          throw new Error("you should provide interval to the prop getter");
        const { startTime: R, labelWidth: T, left: P } = C;
        return {
          style: {
            ...D,
            left: P,
            width: T,
            position: "absolute"
          },
          key: `label-${R.valueOf()}`
        };
      }
    }), Object.defineProperty(this, "getStateAndHelpers", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const {
          /*canvasTimeStart,
          canvasTimeEnd,
          timelineWidth,
          visibleTimeStart,
          visibleTimeEnd,*/
          unit: S,
          showPeriod: C,
          headerData: D
        } = this.props;
        return {
          /*timelineContext: {
            timelineWidth,
            visibleTimeStart,
            visibleTimeEnd,
            canvasTimeStart,
            canvasTimeEnd,
          },*/
          headerContext: {
            unit: S,
            intervals: this.state.intervals
          },
          getRootProps: this.getRootProps,
          getIntervalProps: this.getIntervalProps,
          showPeriod: C,
          data: D
        };
      }
    });
    const { canvasTimeStart: s, canvasTimeEnd: u, unit: v, timeSteps: f, getLeftOffsetFromDate: m } = i, y = this.getHeaderIntervals({
      canvasTimeStart: s,
      canvasTimeEnd: u,
      unit: v,
      timeSteps: f,
      getLeftOffsetFromDate: m
    });
    this.state = {
      intervals: y
    };
  }
  /*shouldComponentUpdate(nextProps: CustomHeaderProps<Data>) {
    if (
      nextProps.canvasTimeStart !== this.props.canvasTimeStart ||
      nextProps.canvasTimeEnd !== this.props.canvasTimeEnd ||
      nextProps.canvasWidth !== this.props.canvasWidth ||
      nextProps.unit !== this.props.unit ||
      nextProps.timeSteps !== this.props.timeSteps ||
      nextProps.showPeriod !== this.props.showPeriod ||
      nextProps.children !== this.props.children ||
      nextProps.headerData !== this.props.headerData
    ) {
      return true
    }
    return false
  }*/
  componentDidUpdate(i) {
    if (!xr(i, this.props)) {
      const { canvasTimeStart: s, canvasTimeEnd: u, unit: v, timeSteps: f, getLeftOffsetFromDate: m } = this.props, y = this.getHeaderIntervals({
        canvasTimeStart: s,
        canvasTimeEnd: u,
        unit: v,
        timeSteps: f,
        getLeftOffsetFromDate: m
      });
      this.setState({ intervals: y });
    }
  }
  render() {
    const i = this.getStateAndHelpers();
    return this.props.children(i);
  }
}
Object.defineProperty(ro, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    height: 30
  }
});
function Qd({ children: a, unit: i, headerData: s, height: u }) {
  const { getTimelineState: v, showPeriod: f, getLeftOffsetFromDate: m } = hd(), y = v(), { timeSteps: S } = Wr();
  return j(ro, { children: a, timeSteps: S, showPeriod: f, unit: i || y.timelineUnit, ...y, headerData: s, getLeftOffsetFromDate: m, height: u });
}
var bi = Number.isNaN || function(i) {
  return typeof i == "number" && i !== i;
};
function ef(a, i) {
  return !!(a === i || bi(a) && bi(i));
}
function tf(a, i) {
  if (a.length !== i.length)
    return !1;
  for (var s = 0; s < a.length; s++)
    if (!ef(a[s], i[s]))
      return !1;
  return !0;
}
function yi(a, i) {
  i === void 0 && (i = tf);
  var s = null;
  function u() {
    for (var v = [], f = 0; f < arguments.length; f++)
      v[f] = arguments[f];
    if (s && s.lastThis === this && i(v, s.lastArgs))
      return s.lastResult;
    var m = a.apply(this, v);
    return s = {
      lastResult: m,
      lastArgs: v,
      lastThis: this
    }, m;
  }
  return u.clear = function() {
    s = null;
  }, u;
}
class rf extends Z.PureComponent {
  constructor() {
    super(...arguments), Object.defineProperty(this, "onIntervalClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { primaryHeader: i, interval: s, unit: u, showPeriod: v } = this.props;
        if (i) {
          const f = Dr(u), m = s.startTime.clone().startOf(f), y = s.startTime.clone().endOf(f);
          v(m, y);
        } else
          v(s.startTime, s.endTime);
      }
    }), Object.defineProperty(this, "getIntervalProps", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i = {}) => ({
        ...this.props.getIntervalProps({
          interval: this.props.interval,
          ...i
        }),
        onClick: Pe(this.onIntervalClick, i.onClick)
      })
    });
  }
  render() {
    const { intervalText: i, interval: s, intervalRenderer: u, headerData: v } = this.props, f = u;
    if (f)
      return f({
        getIntervalProps: this.getIntervalProps,
        intervalContext: {
          interval: s,
          intervalText: i
        },
        data: v
      });
    const { key: m, ...y } = this.getIntervalProps();
    return Tt(
      "div",
      { "data-testid": "dateHeaderInterval", ...y, key: m, className: `rct-dateHeader ${this.props.primaryHeader ? "rct-dateHeader-primary" : ""}` },
      j("span", { children: i })
    );
  }
}
function nf({ headerContext: { intervals: a, unit: i }, getRootProps: s, getIntervalProps: u, showPeriod: v, data: { style: f, intervalRenderer: m, className: y, getLabelFormat: S, unitProp: C, headerData: D } }) {
  return j("div", { "data-testid": "dateHeader", className: y, ...s({ style: f }), children: a.map((R) => {
    const T = S([R.startTime, R.endTime], i, R.labelWidth);
    return j(rf, { unit: i, interval: R, showPeriod: v, intervalText: T, primaryHeader: C === "primaryHeader", getIntervalProps: u, intervalRenderer: m, headerData: D }, `label-${R.startTime.valueOf()}`);
  }) });
}
class of extends Z.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "getHeaderUnit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => this.props.unit === "primaryHeader" ? Dr(this.props.timelineUnit) : this.props.unit ? this.props.unit : this.props.timelineUnit
    }), Object.defineProperty(this, "getRootStyle", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: yi((i) => ({
        height: 30,
        ...i
      }))
    }), Object.defineProperty(this, "getLabelFormat", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (i, s, u) => {
        const { labelFormat: v } = this.props;
        if (typeof v == "string")
          return i[0].format(v);
        if (typeof v == "function")
          return v(i, s, u);
        throw new Error("labelFormat should be function or string");
      }
    }), Object.defineProperty(this, "getHeaderData", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: yi((i, s, u, v, f, m) => ({
        intervalRenderer: i,
        style: s,
        className: u,
        getLabelFormat: v,
        unitProp: f,
        headerData: m
      }))
    });
  }
  render() {
    const i = this.getHeaderUnit(), { height: s } = this.props;
    return j(Qd, { children: nf, unit: i, height: s, headerData: this.getHeaderData(this.props.intervalRenderer, this.getRootStyle(this.props.style), this.props.className, this.getLabelFormat, this.props.unit, this.props.headerData) });
  }
}
function Ti({ labelFormat: a, unit: i, style: s, className: u, intervalRenderer: v, headerData: f, height: m }) {
  return j(Lt, { children: ({ getTimelineState: y }) => {
    const S = y();
    return j(of, { timelineUnit: S.timelineUnit, unit: i, labelFormat: a || sf, style: s, className: u, intervalRenderer: v, headerData: f, height: m });
  } });
}
const sf = ([a], i, s = 150, u = Gd) => {
  let v;
  return s >= 150 ? v = u[i].long : s >= 100 ? v = u[i].mediumLong : s >= 50 ? v = u[i].medium : v = u[i].short, a.format(v);
};
var no = { exports: {} };
(function(a, i) {
  (function(s, u) {
    a.exports = u();
  })(Ie, function() {
    var s = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" };
    return function(u, v, f) {
      var m = v.prototype, y = m.format;
      f.en.formats = s, m.format = function(S) {
        S === void 0 && (S = "YYYY-MM-DDTHH:mm:ssZ");
        var C = this.$locale().formats, D = function(R, T) {
          return R.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(P, _, O) {
            var k = O && O.toUpperCase();
            return _ || T[O] || s[O] || T[k].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(L, H, X) {
              return H || X.slice(1);
            });
          });
        }(S, C === void 0 ? {} : C);
        return y.call(this, D);
      };
    };
  });
})(no);
var af = no.exports;
const lf = /* @__PURE__ */ rt(af);
ue.extend(lf);
class io extends ae {
  constructor(i) {
    super(i), Object.defineProperty(this, "getTimelineContext", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { width: T, visibleTimeStart: P, visibleTimeEnd: _, canvasTimeStart: O, canvasTimeEnd: k } = this.state, L = _ - P, H = ve(T, this.props.buffer), X = xt(L, T, this.props.timeSteps);
        return {
          canvasWidth: H,
          timelineUnit: X,
          timelineWidth: T,
          visibleTimeStart: P,
          visibleTimeEnd: _,
          canvasTimeStart: O,
          canvasTimeEnd: k
        };
      }
    }), Object.defineProperty(this, "getTimelineUnit", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        const { width: T, visibleTimeStart: P, visibleTimeEnd: _ } = this.state, { timeSteps: O } = this.props, k = _ - P;
        return xt(k, T, O);
      }
    }), Object.defineProperty(this, "state", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "scrollComponent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "scrollHeaderRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "resize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T = this.props) => {
        var V;
        const { width: P } = ((V = this.container.current) == null ? void 0 : V.getBoundingClientRect()) ?? { width: 0 }, _ = P - T.sidebarWidth - T.rightSidebarWidth, O = ve(_, T.buffer), { dimensionItems: k, height: L, groupHeights: H, groupTops: X } = $e(T.items, T.groups, O, this.state.canvasTimeStart, this.state.canvasTimeEnd, T.keys, T.lineHeight, T.itemHeightRatio, T.stackItems, this.state.draggingItem, this.state.resizingItem, this.state.dragTime, this.state.resizingEdge, this.state.resizeTime, this.state.newGroupOrder, T.itemVerticalGap);
        this.setState({
          width: _,
          dimensionItems: k,
          height: L,
          groupHeights: H,
          groupTops: X
        });
        const B = _ * ((T.buffer - 1) / 2);
        this.scrollComponent && (this.scrollComponent.scrollLeft = B), this.scrollHeaderRef && (this.scrollHeaderRef.scrollLeft = B);
      }
    }), Object.defineProperty(this, "onScroll", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        var L, H;
        const P = this.state.width, _ = this.state.canvasTimeStart, O = this.state.visibleTimeEnd - this.state.visibleTimeStart, k = _ + O * T / P;
        (this.state.visibleTimeStart !== k || this.state.visibleTimeEnd !== k + O) && ((H = (L = this.props).onTimeChange) == null || H.call(L, k, k + O, this.updateScrollCanvas, this.getTimelineUnit()));
      }
    }), Object.defineProperty(this, "updateScrollCanvas", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P, _ = !1, O = this.props.items, k = this.props.groups) => {
        this.setState(Cr(T, P, _, O, k, this.props, this.state));
      }
    }), Object.defineProperty(this, "handleWheelZoom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P, _) => {
        this.changeZoom(1 + T * _ / 500, P / this.state.width);
      }
    }), Object.defineProperty(this, "changeZoom", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P = 0.5) => {
        const { minZoom: _, maxZoom: O } = this.props, k = this.state.visibleTimeEnd - this.state.visibleTimeStart, L = Math.min(Math.max(Math.round(k * T), _), O), H = Math.round(this.state.visibleTimeStart + (k - L) * P);
        this.props.onTimeChange && this.props.onTimeChange(H, H + L, this.updateScrollCanvas, this.getTimelineUnit());
      }
    }), Object.defineProperty(this, "showPeriod", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P) => {
        var L, H;
        const _ = T.valueOf(), k = P.valueOf() - _;
        k < this.props.minZoom || (H = (L = this.props).onTimeChange) == null || H.call(L, _, _ + k, this.updateScrollCanvas, this.getTimelineUnit());
      }
    }), Object.defineProperty(this, "selectItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P, _) => {
        if (this.isItemSelected(T) || this.props.itemTouchSendsClick && P === "touch") {
          if (T && this.props.onItemClick) {
            const O = this.timeFromItemEvent(_);
            this.props.onItemClick(T, _, O);
          }
        } else if (this.setState({ selectedItem: T }), T && this.props.onItemSelect) {
          const O = this.timeFromItemEvent(_);
          this.props.onItemSelect(T, _, O);
        } else T === null && this.props.onItemDeselect && this.props.onItemDeselect(_);
      }
    }), Object.defineProperty(this, "doubleClickItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P) => {
        if (this.props.onItemDoubleClick) {
          const _ = this.timeFromItemEvent(P);
          this.props.onItemDoubleClick(T, P, _);
        }
      }
    }), Object.defineProperty(this, "contextMenuClickItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P) => {
        if (this.props.onItemContextMenu) {
          const _ = this.timeFromItemEvent(P);
          this.props.onItemContextMenu(T, P, _);
        }
      }
    }), Object.defineProperty(this, "getTimeFromRowClickEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        const { dragSnap: P, buffer: _ } = this.props, { width: O, canvasTimeStart: k, canvasTimeEnd: L } = this.state, { offsetX: H } = T.nativeEvent;
        let X = Mr(k, L, ve(O, _), H);
        return X = Math.floor(X / P) * P, X;
      }
    }), Object.defineProperty(this, "timeFromItemEvent", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        const { width: P, visibleTimeStart: _, visibleTimeEnd: O } = this.state, k = this.props.dragSnap, L = this.scrollComponent, { left: H } = L.getBoundingClientRect(), B = (T.clientX - H) / P, V = O - _, le = B * V;
        let w = Math.round(_ + le);
        return w = Math.floor(w / k) * k, w;
      }
    }), Object.defineProperty(this, "dragItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P, _) => {
        const O = this.props.groups[_], k = this.props.keys;
        this.setState({
          draggingItem: T,
          dragTime: P,
          newGroupOrder: _,
          dragGroupTitle: O ? Y(O, k.groupLabelKey) : ""
        }), this.updatingItem({
          eventType: "move",
          itemId: T,
          time: P,
          newGroupOrder: _
        });
      }
    }), Object.defineProperty(this, "dropItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P, _) => {
        this.setState({ draggingItem: null, dragTime: null, dragGroupTitle: null }), this.props.onItemMove && this.props.onItemMove(T, P, _);
      }
    }), Object.defineProperty(this, "resizingItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P, _) => {
        this.setState({
          resizingItem: T,
          resizingEdge: _,
          resizeTime: P
        }), this.updatingItem({
          eventType: "resize",
          itemId: T,
          time: P,
          edge: _ || void 0
        });
      }
    }), Object.defineProperty(this, "resizedItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P, _, O) => {
        this.setState({ resizingItem: null, resizingEdge: null, resizeTime: null }), this.props.onItemResize && O !== 0 && this.props.onItemResize(T, P, _);
      }
    }), Object.defineProperty(this, "updatingItem", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: ({ eventType: T, itemId: P, time: _, edge: O, newGroupOrder: k }) => {
        this.props.onItemDrag && (T === "move" ? this.props.onItemDrag({
          eventType: T,
          itemId: P,
          time: _,
          newGroupOrder: k
        }) : this.props.onItemDrag({
          eventType: T,
          itemId: P,
          time: _,
          edge: O
        }));
      }
    }), Object.defineProperty(this, "handleRowClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P) => {
        if (this.hasSelectedItem() && this.selectItem(null, "click", T), this.props.onCanvasClick == null)
          return;
        const _ = this.getTimeFromRowClickEvent(T), O = Y(this.props.groups[P], this.props.keys.groupIdKey);
        this.props.onCanvasClick(O, _, T);
      }
    }), Object.defineProperty(this, "handleRowDoubleClick", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P) => {
        if (this.props.onCanvasDoubleClick == null)
          return;
        const _ = this.getTimeFromRowClickEvent(T), O = Y(this.props.groups[P], this.props.keys.groupIdKey);
        this.props.onCanvasDoubleClick(O, _, T);
      }
    }), Object.defineProperty(this, "handleScrollContextMenu", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P) => {
        if (this.props.onCanvasContextMenu == null)
          return;
        const _ = this.getTimeFromRowClickEvent(T), O = Y(this.props.groups[P], this.props.keys.groupIdKey);
        this.props.onCanvasContextMenu && (T.preventDefault(), this.props.onCanvasContextMenu(O, _, T));
      }
    }), Object.defineProperty(this, "handleHeaderRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        this.scrollHeaderRef = T, this.props.headerRef && this.props.headerRef(T);
      }
    }), Object.defineProperty(this, "isTimelineHeader", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => T.type === void 0 ? !1 : T.type.secretKey === Er.secretKey
    }), Object.defineProperty(this, "renderHeaders", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => {
        if (this.props.children) {
          let T;
          if (Z.Children.map(this.props.children, (P) => {
            this.isTimelineHeader(P) && (T = P);
          }), T)
            return T;
        }
        return ze(Er, { children: [j(Ti, { unit: "primaryHeader" }), j(Ti, {})] });
      }
    }), Object.defineProperty(this, "getScrollElementRef", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T) => {
        this.props.scrollRef && this.props.scrollRef(T), this.scrollComponent = T;
      }
    }), Object.defineProperty(this, "container", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: Z.createRef()
    }), Object.defineProperty(this, "getBoundingClientRect", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: () => this.scrollComponent.getBoundingClientRect()
    }), Object.defineProperty(this, "calculateDropCoordinatesToTimeAndGroup", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: (T, P) => {
        const _ = ve(this.state.width, this.props.buffer), O = Mt(this.state.canvasTimeStart, this.state.canvasTimeEnd, _), k = Ct(this.scrollComponent).offsetLeft, L = Ot(this.scrollComponent), H = (T - k + L.scrollLeft) * O + this.state.canvasTimeStart;
        let X = 0;
        for (const V of this.state.groupTops)
          if (P > Number(V))
            X = this.state.groupTops.indexOf(V);
          else
            break;
        if (!this.props.dragSnap)
          return { time: H, groupIndex: X };
        const B = ue().utcOffset() * 60 * 1e3;
        return {
          time: Math.round(H / this.props.dragSnap) * this.props.dragSnap - B % this.props.dragSnap,
          groupIndex: X
        };
      }
    }), this.getSelected = this.getSelected.bind(this), this.hasSelectedItem = this.hasSelectedItem.bind(this), this.isItemSelected = this.isItemSelected.bind(this);
    let s = null, u = null;
    if (this.props.defaultTimeStart && this.props.defaultTimeEnd)
      s = this.props.defaultTimeStart, u = this.props.defaultTimeEnd;
    else if (this.props.visibleTimeStart && this.props.visibleTimeEnd)
      s = this.props.visibleTimeStart, u = this.props.visibleTimeEnd;
    else
      throw new Error('You must provide either "defaultTimeStart" and "defaultTimeEnd" or "visibleTimeStart" and "visibleTimeEnd" to initialize the Timeline');
    const [v, f] = $r(s, u, i.buffer), m = {
      width: 1e3,
      visibleTimeStart: s,
      visibleTimeEnd: u,
      canvasTimeStart: v,
      canvasTimeEnd: f,
      selectedItem: null,
      dragTime: null,
      dragGroupTitle: null,
      resizeTime: null,
      resizingItem: null,
      resizingEdge: null,
      newGroupOrder: 0
      //CHECK
    }, y = ve(m.width, i.buffer), { dimensionItems: S, height: C, groupHeights: D, groupTops: R } = $e(i.items, i.groups, y, m.canvasTimeStart, m.canvasTimeEnd, i.keys, i.lineHeight, i.itemHeightRatio, i.stackItems, m.draggingItem, m.resizingItem, m.dragTime, m.resizingEdge, m.resizeTime, m.newGroupOrder, i.itemVerticalGap);
    m.dimensionItems = S, m.height = C, m.groupHeights = D, m.groupTops = R, this.state = m;
  }
  componentDidMount() {
    this.resize(this.props), this.props.resizeDetector && this.props.resizeDetector.addListener && this.props.resizeDetector.addListener(this), gi.addListener(this);
  }
  componentWillUnmount() {
    this.props.resizeDetector && this.props.resizeDetector.addListener && this.props.resizeDetector.removeListener(this), gi.removeListener(this);
  }
  static getDerivedStateFromProps(i, s) {
    const { visibleTimeStart: u, visibleTimeEnd: v, items: f, groups: m } = i, y = { items: f, groups: m }, S = f !== s.items || m !== s.groups;
    if (u && v)
      Object.assign(y, Cr(u, v, S, f, m, i, s));
    else if (S) {
      const C = ve(s.width, i.buffer);
      Object.assign(y, $e(f, m, C, s.canvasTimeStart, s.canvasTimeEnd, i.keys, i.lineHeight, i.itemHeightRatio, i.stackItems, s.draggingItem, s.resizingItem, s.dragTime, s.resizingEdge, s.resizeTime, s.newGroupOrder, i.itemVerticalGap));
    }
    return y;
  }
  componentDidUpdate(i, s) {
    const u = this.state.visibleTimeEnd - this.state.visibleTimeStart, v = s.visibleTimeEnd - s.visibleTimeStart;
    this.props.onZoom && u !== v && this.props.onZoom(this.getTimelineContext(), this.getTimelineUnit()), this.props.onBoundsChange && this.state.canvasTimeStart !== s.canvasTimeStart && this.props.onBoundsChange(this.state.canvasTimeStart, this.state.canvasTimeStart + u * 3);
    const f = Math.round(this.state.width * (this.state.visibleTimeStart - this.state.canvasTimeStart) / u);
    (Math.round(s.width * (s.visibleTimeStart - s.canvasTimeStart) / v) !== f || this.scrollComponent.scrollLeft !== f) && (this.scrollComponent.scrollLeft = f, this.scrollHeaderRef.scrollLeft = f);
  }
  columns(i, s, u, v, f, m) {
    var y;
    return j(md, { canvasTimeStart: i, canvasTimeEnd: s, canvasWidth: u, lineCount: ((y = this.props.groups) == null ? void 0 : y.length) || 0, minUnit: v, timeSteps: f, height: m, verticalLineClassNamesForTime: this.props.verticalLineClassNamesForTime });
  }
  rows(i, s, u) {
    var v;
    return j(Td, { groups: u, canvasWidth: i, lineCount: ((v = this.props.groups) == null ? void 0 : v.length) || 0, groupHeights: s, clickTolerance: this.props.clickTolerance, onRowClick: this.handleRowClick, onRowDoubleClick: this.handleRowDoubleClick, horizontalLineClassNamesForGroup: this.props.horizontalLineClassNamesForGroup, onRowContextClick: this.handleScrollContextMenu });
  }
  items({ canvasTimeStart: i, canvasTimeEnd: s, canvasWidth: u, dimensionItems: v, groupTops: f }) {
    return j(vd, { canvasTimeStart: i, canvasTimeEnd: s, canvasWidth: u, dimensionItems: v, groupTops: f, items: this.props.items, groups: this.props.groups, keys: this.props.keys, selectedItem: this.state.selectedItem || void 0, dragSnap: this.props.dragSnap, minResizeWidth: this.props.minResizeWidth, canChangeGroup: this.props.canChangeGroup, canMove: this.props.canMove, canResize: this.props.canResize, useResizeHandle: this.props.useResizeHandle, canSelect: this.props.canSelect, moveResizeValidator: this.props.moveResizeValidator, itemSelect: this.selectItem, itemDrag: this.dragItem, itemDrop: this.dropItem, onItemDoubleClick: this.doubleClickItem, onItemContextMenu: this.props.onItemContextMenu ? this.contextMenuClickItem : void 0, itemResizing: this.resizingItem, itemResized: this.resizedItem, itemRenderer: this.props.itemRenderer, selected: this.props.selected, scrollRef: this.scrollComponent });
  }
  sidebar(i, s) {
    const { sidebarWidth: u } = this.props;
    return u && j(fi, { groups: this.props.groups, groupRenderer: this.props.groupRenderer, keys: this.props.keys, width: u, groupHeights: s, height: i });
  }
  rightSidebar(i, s) {
    const { rightSidebarWidth: u } = this.props;
    return u && j(fi, { groups: this.props.groups, keys: this.props.keys, groupRenderer: this.props.groupRenderer, isRightSidebar: !0, width: u, groupHeights: s, height: i });
  }
  childrenWithProps(i, s, u, v, f, m, y, S, C, D, R) {
    if (!this.props.children)
      return null;
    const T = Array.isArray(this.props.children) ? this.props.children.filter((_) => _) : [this.props.children], P = {
      canvasTimeStart: i,
      canvasTimeEnd: s,
      canvasWidth: u,
      visibleTimeStart: S,
      visibleTimeEnd: C,
      dimensionItems: v,
      items: this.props.items,
      groups: this.props.groups,
      keys: this.props.keys,
      groupHeights: f,
      groupTops: m,
      selected: this.getSelected(),
      height: y,
      minUnit: D,
      timeSteps: R
    };
    return Z.Children.map(T, (_) => this.isTimelineHeader(_) ? null : Z.cloneElement(_, P));
  }
  getSelected() {
    return this.state.selectedItem && !this.props.selected ? [this.state.selectedItem] : this.props.selected || [];
  }
  hasSelectedItem() {
    return Array.isArray(this.props.selected) ? this.props.selected.length > 0 : !!this.state.selectedItem;
  }
  isItemSelected(i) {
    return this.getSelected().some((u) => u === i);
  }
  render() {
    const { items: i, groups: s, sidebarWidth: u, rightSidebarWidth: v, timeSteps: f, traditionalZoom: m, buffer: y } = this.props, { draggingItem: S, resizingItem: C, width: D, visibleTimeStart: R, visibleTimeEnd: T, canvasTimeStart: P, canvasTimeEnd: _ } = this.state;
    let { dimensionItems: O, height: k, groupHeights: L, groupTops: H } = this.state;
    const X = T - R, B = ve(D, y), V = xt(X, D, f);
    if (!!S || !!C) {
      const ce = $e(i, s, B, this.state.canvasTimeStart, this.state.canvasTimeEnd, this.props.keys, this.props.lineHeight, this.props.itemHeightRatio, this.props.stackItems, this.state.draggingItem, this.state.resizingItem, this.state.dragTime, this.state.resizingEdge, this.state.resizeTime, this.state.newGroupOrder, this.props.itemVerticalGap);
      O = ce.dimensionItems, k = ce.height, L = ce.groupHeights, H = ce.groupTops;
    }
    const w = {
      height: `${k}px`
    };
    return j(pd, { visibleTimeStart: R, visibleTimeEnd: T, canvasTimeStart: P, canvasTimeEnd: _, canvasWidth: B, showPeriod: this.showPeriod, timelineUnit: V, timelineWidth: this.state.width, children: j(Rd, { children: j(Kd, { registerScroll: this.handleHeaderRef, timeSteps: f, leftSidebarWidth: this.props.sidebarWidth, rightSidebarWidth: this.props.rightSidebarWidth, children: ze("div", { style: this.props.style, ref: this.container, className: `react-calendar-timeline ${this.props.className}`, children: [this.renderHeaders(), ze("div", { style: w, className: "rct-outer", children: [u > 0 ? this.sidebar(k, L) : null, j(wd, { scrollRef: this.getScrollElementRef, width: D, height: k, onZoom: this.changeZoom, onWheelZoom: this.handleWheelZoom, traditionalZoom: !!m, onScroll: this.onScroll, children: ze(Hd, { children: [this.columns(P, _, B, V, f, k), this.rows(B, L, s), this.items({
      canvasTimeStart: P,
      canvasTimeEnd: _,
      canvasWidth: B,
      dimensionItems: O,
      groupTops: H
    }), this.childrenWithProps(P, _, B, O, L, H, k, R, T, V, f)] }) }), v > 0 ? this.rightSidebar(k, L) : null] })] }) }) }) });
  }
}
Object.defineProperty(io, "setDayjsLocale", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: ue.locale
});
Object.defineProperty(io, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    sidebarWidth: 150,
    rightSidebarWidth: 0,
    dragSnap: 1e3 * 60 * 15,
    // 15min
    minResizeWidth: 20,
    lineHeight: 30,
    itemHeightRatio: 0.65,
    buffer: 3,
    minZoom: 60 * 60 * 1e3,
    // 1 hour
    maxZoom: 5 * 365.24 * 86400 * 1e3,
    // 5 years
    clickTolerance: 3,
    // how many pixels can we drag for it to be still considered a click?
    canChangeGroup: !0,
    canMove: !0,
    canResize: "right",
    useResizeHandle: !1,
    canSelect: !0,
    stackItems: !1,
    traditionalZoom: !1,
    horizontalLineClassNamesForGroup: null,
    onItemMove: null,
    onItemResize: null,
    onItemClick: null,
    onItemSelect: null,
    onItemDeselect: null,
    onItemDrag: null,
    onCanvasClick: null,
    onItemDoubleClick: null,
    onItemContextMenu: null,
    onZoom: null,
    verticalLineClassNamesForTime: null,
    moveResizeValidator: null,
    dayBackground: null,
    defaultTimeStart: null,
    defaultTimeEnd: null,
    itemTouchSendsClick: !1,
    style: {},
    className: "",
    keys: Ud,
    timeSteps: Nd,
    headerRef: () => {
    },
    scrollRef: () => {
    },
    // if you pass in visibleTimeStart and visibleTimeEnd, you must also pass onTimeChange(visibleTimeStart, visibleTimeEnd),
    // which needs to update the props visibleTimeStart and visibleTimeEnd to the ones passed
    visibleTimeStart: null,
    visibleTimeEnd: null,
    onTimeChange: function(a, i, s) {
      s(a, i);
    },
    // called when the canvas area of the calendar changes
    onBoundsChange: null,
    children: null,
    selected: null
  }
});
const wf = (a) => a.children || null;
class oo extends Z.Component {
  constructor() {
    super(...arguments), Object.defineProperty(this, "unsubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "getMarker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  componentDidMount() {
    const { unsubscribe: i, getMarker: s } = this.props.subscribeMarker({
      type: xe.Today,
      renderer: this.props.children,
      interval: this.props.interval
    });
    this.unsubscribe = i, this.getMarker = s;
  }
  componentWillUnmount() {
    this.unsubscribe != null && (this.unsubscribe(), this.unsubscribe = null);
  }
  componentDidUpdate(i) {
    if (i.interval !== this.props.interval && this.getMarker) {
      const s = this.getMarker();
      this.props.updateMarker({
        ...s,
        interval: this.props.interval
      });
    }
  }
  render() {
    return null;
  }
}
Object.defineProperty(oo, "defaultProps", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: {
    interval: 1e3 * 10
    // default to ten seconds
  }
});
const cf = (a) => j(Ht, { children: ({ subscribeMarker: i, updateMarker: s }) => j(oo, { subscribeMarker: i, updateMarker: s, ...a }) });
cf.displayName = "TodayMarkerWrapper";
class uf extends ae {
  constructor() {
    super(...arguments), Object.defineProperty(this, "unsubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    }), Object.defineProperty(this, "getMarker", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  componentDidUpdate(i) {
    if (i.date !== this.props.date && this.getMarker) {
      const s = this.getMarker();
      this.props.updateMarker({ ...s, date: this.props.date });
    }
  }
  componentDidMount() {
    const { unsubscribe: i, getMarker: s } = this.props.subscribeMarker({
      type: xe.Custom,
      renderer: this.props.children,
      date: this.props.date
    });
    this.unsubscribe = i, this.getMarker = s;
  }
  componentWillUnmount() {
    this.unsubscribe != null && (this.unsubscribe(), this.unsubscribe = null);
  }
  render() {
    return null;
  }
}
const pf = (a) => j(Ht, { children: ({ subscribeMarker: i, updateMarker: s }) => j(uf, { subscribeMarker: i, updateMarker: s, ...a }) });
pf.displayName = "CustomMarkerWrapper";
class hf extends ae {
  constructor() {
    super(...arguments), Object.defineProperty(this, "unsubscribe", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: null
    });
  }
  componentDidMount() {
    const { unsubscribe: i } = this.props.subscribeMarker({
      type: xe.Cursor,
      renderer: this.props.children
    });
    this.unsubscribe = i;
  }
  componentWillUnmount() {
    this.unsubscribe != null && (this.unsubscribe(), this.unsubscribe = null);
  }
  render() {
    return null;
  }
}
const df = (a) => j(Ht, { children: ({ subscribeMarker: i }) => j(hf, { subscribeMarker: i, ...a }) });
df.displayName = "CursorMarkerWrapper";
export {
  df as CursorMarker,
  Qd as CustomHeader,
  pf as CustomMarker,
  Ti as DateHeader,
  yd as GroupRow,
  vd as RowItems,
  St as SidebarHeader,
  io as Timeline,
  Er as TimelineHeaders,
  wf as TimelineMarkers,
  cf as TodayMarker,
  mf as calendarUtils,
  io as default
};
//# sourceMappingURL=react-calendar-timeline.es.js.map
